import {
  base64,
  bech32,
  bytesToHex,
  cbc,
  chacha20,
  concatBytes,
  equalBytes,
  expand,
  extract,
  hexToBytes,
  hmac,
  randomBytes,
  schnorr,
  secp256k1,
  sha256
} from "./chunk-UC7MHN2T.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/.pnpm/nostr-tools@2.15.0_typescript@5.9.2/node_modules/nostr-tools/lib/esm/index.js
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var verifiedSymbol = Symbol("verified");
var isRecord = (obj) => obj instanceof Object;
function validateEvent(event) {
  if (!isRecord(event))
    return false;
  if (typeof event.kind !== "number")
    return false;
  if (typeof event.content !== "string")
    return false;
  if (typeof event.created_at !== "number")
    return false;
  if (typeof event.pubkey !== "string")
    return false;
  if (!event.pubkey.match(/^[a-f0-9]{64}$/))
    return false;
  if (!Array.isArray(event.tags))
    return false;
  for (let i22 = 0; i22 < event.tags.length; i22++) {
    let tag = event.tags[i22];
    if (!Array.isArray(tag))
      return false;
    for (let j3 = 0; j3 < tag.length; j3++) {
      if (typeof tag[j3] !== "string")
        return false;
    }
  }
  return true;
}
var utils_exports = {};
__export(utils_exports, {
  Queue: () => Queue,
  QueueNode: () => QueueNode,
  binarySearch: () => binarySearch,
  bytesToHex: () => bytesToHex,
  hexToBytes: () => hexToBytes,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList,
  normalizeURL: () => normalizeURL,
  utf8Decoder: () => utf8Decoder,
  utf8Encoder: () => utf8Encoder
});
var utf8Decoder = new TextDecoder("utf-8");
var utf8Encoder = new TextEncoder();
function normalizeURL(url) {
  try {
    if (url.indexOf("://") === -1)
      url = "wss://" + url;
    let p3 = new URL(url);
    p3.pathname = p3.pathname.replace(/\/+/g, "/");
    if (p3.pathname.endsWith("/"))
      p3.pathname = p3.pathname.slice(0, -1);
    if (p3.port === "80" && p3.protocol === "ws:" || p3.port === "443" && p3.protocol === "wss:")
      p3.port = "";
    p3.searchParams.sort();
    p3.hash = "";
    return p3.toString();
  } catch (e2) {
    throw new Error(`Invalid URL: ${url}`);
  }
}
function insertEventIntoDescendingList(sortedArray, event) {
  const [idx, found] = binarySearch(sortedArray, (b3) => {
    if (event.id === b3.id)
      return 0;
    if (event.created_at === b3.created_at)
      return -1;
    return b3.created_at - event.created_at;
  });
  if (!found) {
    sortedArray.splice(idx, 0, event);
  }
  return sortedArray;
}
function insertEventIntoAscendingList(sortedArray, event) {
  const [idx, found] = binarySearch(sortedArray, (b3) => {
    if (event.id === b3.id)
      return 0;
    if (event.created_at === b3.created_at)
      return -1;
    return event.created_at - b3.created_at;
  });
  if (!found) {
    sortedArray.splice(idx, 0, event);
  }
  return sortedArray;
}
function binarySearch(arr, compare) {
  let start = 0;
  let end = arr.length - 1;
  while (start <= end) {
    const mid = Math.floor((start + end) / 2);
    const cmp = compare(arr[mid]);
    if (cmp === 0) {
      return [mid, true];
    }
    if (cmp < 0) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }
  return [start, false];
}
var QueueNode = class {
  constructor(message) {
    __publicField(this, "value");
    __publicField(this, "next", null);
    __publicField(this, "prev", null);
    this.value = message;
  }
};
var Queue = class {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
    this.first = null;
    this.last = null;
  }
  enqueue(value) {
    const newNode = new QueueNode(value);
    if (!this.last) {
      this.first = newNode;
      this.last = newNode;
    } else if (this.last === this.first) {
      this.last = newNode;
      this.last.prev = this.first;
      this.first.next = newNode;
    } else {
      newNode.prev = this.last;
      this.last.next = newNode;
      this.last = newNode;
    }
    return true;
  }
  dequeue() {
    if (!this.first)
      return null;
    if (this.first === this.last) {
      const target2 = this.first;
      this.first = null;
      this.last = null;
      return target2.value;
    }
    const target = this.first;
    this.first = target.next;
    if (this.first) {
      this.first.prev = null;
    }
    return target.value;
  }
};
var JS = class {
  generateSecretKey() {
    return schnorr.utils.randomPrivateKey();
  }
  getPublicKey(secretKey) {
    return bytesToHex(schnorr.getPublicKey(secretKey));
  }
  finalizeEvent(t2, secretKey) {
    const event = t2;
    event.pubkey = bytesToHex(schnorr.getPublicKey(secretKey));
    event.id = getEventHash(event);
    event.sig = bytesToHex(schnorr.sign(getEventHash(event), secretKey));
    event[verifiedSymbol] = true;
    return event;
  }
  verifyEvent(event) {
    if (typeof event[verifiedSymbol] === "boolean")
      return event[verifiedSymbol];
    const hash = getEventHash(event);
    if (hash !== event.id) {
      event[verifiedSymbol] = false;
      return false;
    }
    try {
      const valid = schnorr.verify(event.sig, hash, event.pubkey);
      event[verifiedSymbol] = valid;
      return valid;
    } catch (err) {
      event[verifiedSymbol] = false;
      return false;
    }
  }
};
function serializeEvent(evt) {
  if (!validateEvent(evt))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);
}
function getEventHash(event) {
  let eventHash = sha256(utf8Encoder.encode(serializeEvent(event)));
  return bytesToHex(eventHash);
}
var i = new JS();
var generateSecretKey = i.generateSecretKey;
var getPublicKey = i.getPublicKey;
var finalizeEvent = i.finalizeEvent;
var verifyEvent = i.verifyEvent;
var kinds_exports = {};
__export(kinds_exports, {
  Application: () => Application,
  BadgeAward: () => BadgeAward,
  BadgeDefinition: () => BadgeDefinition,
  BlockedRelaysList: () => BlockedRelaysList,
  BookmarkList: () => BookmarkList,
  Bookmarksets: () => Bookmarksets,
  Calendar: () => Calendar,
  CalendarEventRSVP: () => CalendarEventRSVP,
  ChannelCreation: () => ChannelCreation,
  ChannelHideMessage: () => ChannelHideMessage,
  ChannelMessage: () => ChannelMessage,
  ChannelMetadata: () => ChannelMetadata,
  ChannelMuteUser: () => ChannelMuteUser,
  ClassifiedListing: () => ClassifiedListing,
  ClientAuth: () => ClientAuth,
  CommunitiesList: () => CommunitiesList,
  CommunityDefinition: () => CommunityDefinition,
  CommunityPostApproval: () => CommunityPostApproval,
  Contacts: () => Contacts,
  CreateOrUpdateProduct: () => CreateOrUpdateProduct,
  CreateOrUpdateStall: () => CreateOrUpdateStall,
  Curationsets: () => Curationsets,
  Date: () => Date2,
  DirectMessageRelaysList: () => DirectMessageRelaysList,
  DraftClassifiedListing: () => DraftClassifiedListing,
  DraftLong: () => DraftLong,
  Emojisets: () => Emojisets,
  EncryptedDirectMessage: () => EncryptedDirectMessage,
  EventDeletion: () => EventDeletion,
  FileMetadata: () => FileMetadata,
  FileServerPreference: () => FileServerPreference,
  Followsets: () => Followsets,
  GenericRepost: () => GenericRepost,
  Genericlists: () => Genericlists,
  GiftWrap: () => GiftWrap,
  HTTPAuth: () => HTTPAuth,
  Handlerinformation: () => Handlerinformation,
  Handlerrecommendation: () => Handlerrecommendation,
  Highlights: () => Highlights,
  InterestsList: () => InterestsList,
  Interestsets: () => Interestsets,
  JobFeedback: () => JobFeedback,
  JobRequest: () => JobRequest,
  JobResult: () => JobResult,
  Label: () => Label,
  LightningPubRPC: () => LightningPubRPC,
  LiveChatMessage: () => LiveChatMessage,
  LiveEvent: () => LiveEvent,
  LongFormArticle: () => LongFormArticle,
  Metadata: () => Metadata,
  Mutelist: () => Mutelist,
  NWCWalletInfo: () => NWCWalletInfo,
  NWCWalletRequest: () => NWCWalletRequest,
  NWCWalletResponse: () => NWCWalletResponse,
  NostrConnect: () => NostrConnect,
  OpenTimestamps: () => OpenTimestamps,
  Pinlist: () => Pinlist,
  PrivateDirectMessage: () => PrivateDirectMessage,
  ProblemTracker: () => ProblemTracker,
  ProfileBadges: () => ProfileBadges,
  PublicChatsList: () => PublicChatsList,
  Reaction: () => Reaction,
  RecommendRelay: () => RecommendRelay,
  RelayList: () => RelayList,
  Relaysets: () => Relaysets,
  Report: () => Report,
  Reporting: () => Reporting,
  Repost: () => Repost,
  Seal: () => Seal,
  SearchRelaysList: () => SearchRelaysList,
  ShortTextNote: () => ShortTextNote,
  Time: () => Time,
  UserEmojiList: () => UserEmojiList,
  UserStatuses: () => UserStatuses,
  Zap: () => Zap,
  ZapGoal: () => ZapGoal,
  ZapRequest: () => ZapRequest,
  classifyKind: () => classifyKind,
  isAddressableKind: () => isAddressableKind,
  isEphemeralKind: () => isEphemeralKind,
  isKind: () => isKind,
  isRegularKind: () => isRegularKind,
  isReplaceableKind: () => isReplaceableKind
});
function isRegularKind(kind) {
  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);
}
function isReplaceableKind(kind) {
  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;
}
function isEphemeralKind(kind) {
  return 2e4 <= kind && kind < 3e4;
}
function isAddressableKind(kind) {
  return 3e4 <= kind && kind < 4e4;
}
function classifyKind(kind) {
  if (isRegularKind(kind))
    return "regular";
  if (isReplaceableKind(kind))
    return "replaceable";
  if (isEphemeralKind(kind))
    return "ephemeral";
  if (isAddressableKind(kind))
    return "parameterized";
  return "unknown";
}
function isKind(event, kind) {
  const kindAsArray = kind instanceof Array ? kind : [kind];
  return validateEvent(event) && kindAsArray.includes(event.kind) || false;
}
var Metadata = 0;
var ShortTextNote = 1;
var RecommendRelay = 2;
var Contacts = 3;
var EncryptedDirectMessage = 4;
var EventDeletion = 5;
var Repost = 6;
var Reaction = 7;
var BadgeAward = 8;
var Seal = 13;
var PrivateDirectMessage = 14;
var GenericRepost = 16;
var ChannelCreation = 40;
var ChannelMetadata = 41;
var ChannelMessage = 42;
var ChannelHideMessage = 43;
var ChannelMuteUser = 44;
var OpenTimestamps = 1040;
var GiftWrap = 1059;
var FileMetadata = 1063;
var LiveChatMessage = 1311;
var ProblemTracker = 1971;
var Report = 1984;
var Reporting = 1984;
var Label = 1985;
var CommunityPostApproval = 4550;
var JobRequest = 5999;
var JobResult = 6999;
var JobFeedback = 7e3;
var ZapGoal = 9041;
var ZapRequest = 9734;
var Zap = 9735;
var Highlights = 9802;
var Mutelist = 1e4;
var Pinlist = 10001;
var RelayList = 10002;
var BookmarkList = 10003;
var CommunitiesList = 10004;
var PublicChatsList = 10005;
var BlockedRelaysList = 10006;
var SearchRelaysList = 10007;
var InterestsList = 10015;
var UserEmojiList = 10030;
var DirectMessageRelaysList = 10050;
var FileServerPreference = 10096;
var NWCWalletInfo = 13194;
var LightningPubRPC = 21e3;
var ClientAuth = 22242;
var NWCWalletRequest = 23194;
var NWCWalletResponse = 23195;
var NostrConnect = 24133;
var HTTPAuth = 27235;
var Followsets = 3e4;
var Genericlists = 30001;
var Relaysets = 30002;
var Bookmarksets = 30003;
var Curationsets = 30004;
var ProfileBadges = 30008;
var BadgeDefinition = 30009;
var Interestsets = 30015;
var CreateOrUpdateStall = 30017;
var CreateOrUpdateProduct = 30018;
var LongFormArticle = 30023;
var DraftLong = 30024;
var Emojisets = 30030;
var Application = 30078;
var LiveEvent = 30311;
var UserStatuses = 30315;
var ClassifiedListing = 30402;
var DraftClassifiedListing = 30403;
var Date2 = 31922;
var Time = 31923;
var Calendar = 31924;
var CalendarEventRSVP = 31925;
var Handlerrecommendation = 31989;
var Handlerinformation = 31990;
var CommunityDefinition = 34550;
function matchFilter(filter, event) {
  if (filter.ids && filter.ids.indexOf(event.id) === -1) {
    return false;
  }
  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {
    return false;
  }
  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {
    return false;
  }
  for (let f3 in filter) {
    if (f3[0] === "#") {
      let tagName = f3.slice(1);
      let values = filter[`#${tagName}`];
      if (values && !event.tags.find(([t2, v4]) => t2 === f3.slice(1) && values.indexOf(v4) !== -1))
        return false;
    }
  }
  if (filter.since && event.created_at < filter.since)
    return false;
  if (filter.until && event.created_at > filter.until)
    return false;
  return true;
}
function matchFilters(filters, event) {
  for (let i22 = 0; i22 < filters.length; i22++) {
    if (matchFilter(filters[i22], event)) {
      return true;
    }
  }
  return false;
}
var fakejson_exports = {};
__export(fakejson_exports, {
  getHex64: () => getHex64,
  getInt: () => getInt,
  getSubscriptionId: () => getSubscriptionId,
  matchEventId: () => matchEventId,
  matchEventKind: () => matchEventKind,
  matchEventPubkey: () => matchEventPubkey
});
function getHex64(json, field) {
  let len = field.length + 3;
  let idx = json.indexOf(`"${field}":`) + len;
  let s2 = json.slice(idx).indexOf(`"`) + idx + 1;
  return json.slice(s2, s2 + 64);
}
function getInt(json, field) {
  let len = field.length;
  let idx = json.indexOf(`"${field}":`) + len + 3;
  let sliced = json.slice(idx);
  let end = Math.min(sliced.indexOf(","), sliced.indexOf("}"));
  return parseInt(sliced.slice(0, end), 10);
}
function getSubscriptionId(json) {
  let idx = json.slice(0, 22).indexOf(`"EVENT"`);
  if (idx === -1)
    return null;
  let pstart = json.slice(idx + 7 + 1).indexOf(`"`);
  if (pstart === -1)
    return null;
  let start = idx + 7 + 1 + pstart;
  let pend = json.slice(start + 1, 80).indexOf(`"`);
  if (pend === -1)
    return null;
  let end = start + 1 + pend;
  return json.slice(start + 1, end);
}
function matchEventId(json, id) {
  return id === getHex64(json, "id");
}
function matchEventPubkey(json, pubkey) {
  return pubkey === getHex64(json, "pubkey");
}
function matchEventKind(json, kind) {
  return kind === getInt(json, "kind");
}
var nip42_exports = {};
__export(nip42_exports, {
  makeAuthEvent: () => makeAuthEvent
});
function makeAuthEvent(relayURL, challenge) {
  return {
    kind: ClientAuth,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", relayURL],
      ["challenge", challenge]
    ],
    content: ""
  };
}
async function yieldThread() {
  return new Promise((resolve) => {
    const ch = new MessageChannel();
    const handler = () => {
      ch.port1.removeEventListener("message", handler);
      resolve();
    };
    ch.port1.addEventListener("message", handler);
    ch.port2.postMessage(0);
    ch.port1.start();
  });
}
var SendingOnClosedConnection = class extends Error {
  constructor(message, relay) {
    super(`Tried to send message '${message} on a closed connection to ${relay}.`);
    this.name = "SendingOnClosedConnection";
  }
};
var AbstractRelay = class {
  constructor(url, opts) {
    __publicField(this, "url");
    __publicField(this, "_connected", false);
    __publicField(this, "onclose", null);
    __publicField(this, "onnotice", (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`));
    __publicField(this, "baseEoseTimeout", 4400);
    __publicField(this, "connectionTimeout", 4400);
    __publicField(this, "publishTimeout", 4400);
    __publicField(this, "openSubs", /* @__PURE__ */ new Map());
    __publicField(this, "connectionTimeoutHandle");
    __publicField(this, "connectionPromise");
    __publicField(this, "openCountRequests", /* @__PURE__ */ new Map());
    __publicField(this, "openEventPublishes", /* @__PURE__ */ new Map());
    __publicField(this, "ws");
    __publicField(this, "incomingMessageQueue", new Queue());
    __publicField(this, "queueRunning", false);
    __publicField(this, "challenge");
    __publicField(this, "authPromise");
    __publicField(this, "serial", 0);
    __publicField(this, "verifyEvent");
    __publicField(this, "_WebSocket");
    this.url = normalizeURL(url);
    this.verifyEvent = opts.verifyEvent;
    this._WebSocket = opts.websocketImplementation || WebSocket;
  }
  static async connect(url, opts) {
    const relay = new AbstractRelay(url, opts);
    await relay.connect();
    return relay;
  }
  closeAllSubscriptions(reason) {
    for (let [_3, sub] of this.openSubs) {
      sub.close(reason);
    }
    this.openSubs.clear();
    for (let [_3, ep] of this.openEventPublishes) {
      ep.reject(new Error(reason));
    }
    this.openEventPublishes.clear();
    for (let [_3, cr] of this.openCountRequests) {
      cr.reject(new Error(reason));
    }
    this.openCountRequests.clear();
  }
  get connected() {
    return this._connected;
  }
  async connect() {
    if (this.connectionPromise)
      return this.connectionPromise;
    this.challenge = void 0;
    this.authPromise = void 0;
    this.connectionPromise = new Promise((resolve, reject) => {
      this.connectionTimeoutHandle = setTimeout(() => {
        var _a;
        reject("connection timed out");
        this.connectionPromise = void 0;
        (_a = this.onclose) == null ? void 0 : _a.call(this);
        this.closeAllSubscriptions("relay connection timed out");
      }, this.connectionTimeout);
      try {
        this.ws = new this._WebSocket(this.url);
      } catch (err) {
        clearTimeout(this.connectionTimeoutHandle);
        reject(err);
        return;
      }
      this.ws.onopen = () => {
        clearTimeout(this.connectionTimeoutHandle);
        this._connected = true;
        resolve();
      };
      this.ws.onerror = (ev) => {
        var _a;
        clearTimeout(this.connectionTimeoutHandle);
        reject(ev.message || "websocket error");
        if (this._connected) {
          this._connected = false;
          this.connectionPromise = void 0;
          (_a = this.onclose) == null ? void 0 : _a.call(this);
          this.closeAllSubscriptions("relay connection errored");
        }
      };
      this.ws.onclose = (ev) => {
        var _a;
        clearTimeout(this.connectionTimeoutHandle);
        reject(ev.message || "websocket closed");
        if (this._connected) {
          this._connected = false;
          this.connectionPromise = void 0;
          (_a = this.onclose) == null ? void 0 : _a.call(this);
          this.closeAllSubscriptions("relay connection closed");
        }
      };
      this.ws.onmessage = this._onmessage.bind(this);
    });
    return this.connectionPromise;
  }
  async runQueue() {
    this.queueRunning = true;
    while (true) {
      if (false === this.handleNext()) {
        break;
      }
      await yieldThread();
    }
    this.queueRunning = false;
  }
  handleNext() {
    var _a, _b;
    const json = this.incomingMessageQueue.dequeue();
    if (!json) {
      return false;
    }
    const subid = getSubscriptionId(json);
    if (subid) {
      const so = this.openSubs.get(subid);
      if (!so) {
        return;
      }
      const id = getHex64(json, "id");
      const alreadyHave = (_a = so.alreadyHaveEvent) == null ? void 0 : _a.call(so, id);
      (_b = so.receivedEvent) == null ? void 0 : _b.call(so, this, id);
      if (alreadyHave) {
        return;
      }
    }
    try {
      let data = JSON.parse(json);
      switch (data[0]) {
        case "EVENT": {
          const so = this.openSubs.get(data[1]);
          const event = data[2];
          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {
            so.onevent(event);
          }
          return;
        }
        case "COUNT": {
          const id = data[1];
          const payload = data[2];
          const cr = this.openCountRequests.get(id);
          if (cr) {
            cr.resolve(payload.count);
            this.openCountRequests.delete(id);
          }
          return;
        }
        case "EOSE": {
          const so = this.openSubs.get(data[1]);
          if (!so)
            return;
          so.receivedEose();
          return;
        }
        case "OK": {
          const id = data[1];
          const ok = data[2];
          const reason = data[3];
          const ep = this.openEventPublishes.get(id);
          if (ep) {
            clearTimeout(ep.timeout);
            if (ok)
              ep.resolve(reason);
            else
              ep.reject(new Error(reason));
            this.openEventPublishes.delete(id);
          }
          return;
        }
        case "CLOSED": {
          const id = data[1];
          const so = this.openSubs.get(id);
          if (!so)
            return;
          so.closed = true;
          so.close(data[2]);
          return;
        }
        case "NOTICE":
          this.onnotice(data[1]);
          return;
        case "AUTH": {
          this.challenge = data[1];
          return;
        }
      }
    } catch (err) {
      return;
    }
  }
  async send(message) {
    if (!this.connectionPromise)
      throw new SendingOnClosedConnection(message, this.url);
    this.connectionPromise.then(() => {
      var _a;
      (_a = this.ws) == null ? void 0 : _a.send(message);
    });
  }
  async auth(signAuthEvent) {
    const challenge = this.challenge;
    if (!challenge)
      throw new Error("can't perform auth, no challenge was received");
    if (this.authPromise)
      return this.authPromise;
    this.authPromise = new Promise(async (resolve, reject) => {
      try {
        let evt = await signAuthEvent(makeAuthEvent(this.url, challenge));
        let timeout = setTimeout(() => {
          let ep = this.openEventPublishes.get(evt.id);
          if (ep) {
            ep.reject(new Error("auth timed out"));
            this.openEventPublishes.delete(evt.id);
          }
        }, this.publishTimeout);
        this.openEventPublishes.set(evt.id, { resolve, reject, timeout });
        this.send('["AUTH",' + JSON.stringify(evt) + "]");
      } catch (err) {
        console.warn("subscribe auth function failed:", err);
      }
    });
    return this.authPromise;
  }
  async publish(event) {
    const ret = new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        const ep = this.openEventPublishes.get(event.id);
        if (ep) {
          ep.reject(new Error("publish timed out"));
          this.openEventPublishes.delete(event.id);
        }
      }, this.publishTimeout);
      this.openEventPublishes.set(event.id, { resolve, reject, timeout });
    });
    this.send('["EVENT",' + JSON.stringify(event) + "]");
    return ret;
  }
  async count(filters, params) {
    this.serial++;
    const id = (params == null ? void 0 : params.id) || "count:" + this.serial;
    const ret = new Promise((resolve, reject) => {
      this.openCountRequests.set(id, { resolve, reject });
    });
    this.send('["COUNT","' + id + '",' + JSON.stringify(filters).substring(1));
    return ret;
  }
  subscribe(filters, params) {
    const subscription = this.prepareSubscription(filters, params);
    subscription.fire();
    return subscription;
  }
  prepareSubscription(filters, params) {
    this.serial++;
    const id = params.id || (params.label ? params.label + ":" : "sub:") + this.serial;
    const subscription = new Subscription(this, id, filters, params);
    this.openSubs.set(id, subscription);
    return subscription;
  }
  close() {
    var _a;
    this.closeAllSubscriptions("relay connection closed by us");
    this._connected = false;
    (_a = this.ws) == null ? void 0 : _a.close();
  }
  _onmessage(ev) {
    this.incomingMessageQueue.enqueue(ev.data);
    if (!this.queueRunning) {
      this.runQueue();
    }
  }
};
var Subscription = class {
  constructor(relay, id, filters, params) {
    __publicField(this, "relay");
    __publicField(this, "id");
    __publicField(this, "closed", false);
    __publicField(this, "eosed", false);
    __publicField(this, "filters");
    __publicField(this, "alreadyHaveEvent");
    __publicField(this, "receivedEvent");
    __publicField(this, "onevent");
    __publicField(this, "oneose");
    __publicField(this, "onclose");
    __publicField(this, "eoseTimeout");
    __publicField(this, "eoseTimeoutHandle");
    this.relay = relay;
    this.filters = filters;
    this.id = id;
    this.alreadyHaveEvent = params.alreadyHaveEvent;
    this.receivedEvent = params.receivedEvent;
    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;
    this.oneose = params.oneose;
    this.onclose = params.onclose;
    this.onevent = params.onevent || ((event) => {
      console.warn(
        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,
        event
      );
    });
  }
  fire() {
    this.relay.send('["REQ","' + this.id + '",' + JSON.stringify(this.filters).substring(1));
    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);
  }
  receivedEose() {
    var _a;
    if (this.eosed)
      return;
    clearTimeout(this.eoseTimeoutHandle);
    this.eosed = true;
    (_a = this.oneose) == null ? void 0 : _a.call(this);
  }
  close(reason = "closed by caller") {
    var _a;
    if (!this.closed && this.relay.connected) {
      try {
        this.relay.send('["CLOSE",' + JSON.stringify(this.id) + "]");
      } catch (err) {
        if (err instanceof SendingOnClosedConnection) {
        } else {
          throw err;
        }
      }
      this.closed = true;
    }
    this.relay.openSubs.delete(this.id);
    (_a = this.onclose) == null ? void 0 : _a.call(this, reason);
  }
};
var _WebSocket;
try {
  _WebSocket = WebSocket;
} catch {
}
var Relay = class extends AbstractRelay {
  constructor(url) {
    super(url, { verifyEvent, websocketImplementation: _WebSocket });
  }
  static async connect(url) {
    const relay = new Relay(url);
    await relay.connect();
    return relay;
  }
};
var _WebSocket2;
try {
  _WebSocket2 = WebSocket;
} catch {
}
var nip19_exports = {};
__export(nip19_exports, {
  BECH32_REGEX: () => BECH32_REGEX,
  Bech32MaxSize: () => Bech32MaxSize,
  NostrTypeGuard: () => NostrTypeGuard,
  decode: () => decode,
  decodeNostrURI: () => decodeNostrURI,
  encodeBytes: () => encodeBytes,
  naddrEncode: () => naddrEncode,
  neventEncode: () => neventEncode,
  noteEncode: () => noteEncode,
  nprofileEncode: () => nprofileEncode,
  npubEncode: () => npubEncode,
  nsecEncode: () => nsecEncode
});
var NostrTypeGuard = {
  isNProfile: (value) => /^nprofile1[a-z\d]+$/.test(value || ""),
  isNEvent: (value) => /^nevent1[a-z\d]+$/.test(value || ""),
  isNAddr: (value) => /^naddr1[a-z\d]+$/.test(value || ""),
  isNSec: (value) => /^nsec1[a-z\d]{58}$/.test(value || ""),
  isNPub: (value) => /^npub1[a-z\d]{58}$/.test(value || ""),
  isNote: (value) => /^note1[a-z\d]+$/.test(value || ""),
  isNcryptsec: (value) => /^ncryptsec1[a-z\d]+$/.test(value || "")
};
var Bech32MaxSize = 5e3;
var BECH32_REGEX = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array(number) {
  const uint8Array = new Uint8Array(4);
  uint8Array[0] = number >> 24 & 255;
  uint8Array[1] = number >> 16 & 255;
  uint8Array[2] = number >> 8 & 255;
  uint8Array[3] = number & 255;
  return uint8Array;
}
function decodeNostrURI(nip19code) {
  try {
    if (nip19code.startsWith("nostr:"))
      nip19code = nip19code.substring(6);
    return decode(nip19code);
  } catch (_err) {
    return { type: "invalid", data: null };
  }
}
function decode(code) {
  var _a, _b, _c, _d, _e, _f, _g;
  let { prefix, words } = bech32.decode(code, Bech32MaxSize);
  let data = new Uint8Array(bech32.fromWords(words));
  switch (prefix) {
    case "nprofile": {
      let tlv = parseTLV(data);
      if (!((_a = tlv[0]) == null ? void 0 : _a[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d3) => utf8Decoder.decode(d3)) : []
        }
      };
    }
    case "nevent": {
      let tlv = parseTLV(data);
      if (!((_b = tlv[0]) == null ? void 0 : _b[0]))
        throw new Error("missing TLV 0 for nevent");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (tlv[2] && tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (tlv[3] && tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d3) => utf8Decoder.decode(d3)) : [],
          author: ((_c = tlv[2]) == null ? void 0 : _c[0]) ? bytesToHex(tlv[2][0]) : void 0,
          kind: ((_d = tlv[3]) == null ? void 0 : _d[0]) ? parseInt(bytesToHex(tlv[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let tlv = parseTLV(data);
      if (!((_e = tlv[0]) == null ? void 0 : _e[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((_f = tlv[2]) == null ? void 0 : _f[0]))
        throw new Error("missing TLV 2 for naddr");
      if (tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((_g = tlv[3]) == null ? void 0 : _g[0]))
        throw new Error("missing TLV 3 for naddr");
      if (tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder.decode(tlv[0][0]),
          pubkey: bytesToHex(tlv[2][0]),
          kind: parseInt(bytesToHex(tlv[3][0]), 16),
          relays: tlv[1] ? tlv[1].map((d3) => utf8Decoder.decode(d3)) : []
        }
      };
    }
    case "nsec":
      return { type: prefix, data };
    case "npub":
    case "note":
      return { type: prefix, data: bytesToHex(data) };
    default:
      throw new Error(`unknown prefix ${prefix}`);
  }
}
function parseTLV(data) {
  let result = {};
  let rest = data;
  while (rest.length > 0) {
    let t2 = rest[0];
    let l2 = rest[1];
    let v4 = rest.slice(2, 2 + l2);
    rest = rest.slice(2 + l2);
    if (v4.length < l2)
      throw new Error(`not enough data to read on TLV ${t2}`);
    result[t2] = result[t2] || [];
    result[t2].push(v4);
  }
  return result;
}
function nsecEncode(key) {
  return encodeBytes("nsec", key);
}
function npubEncode(hex) {
  return encodeBytes("npub", hexToBytes(hex));
}
function noteEncode(hex) {
  return encodeBytes("note", hexToBytes(hex));
}
function encodeBech32(prefix, data) {
  let words = bech32.toWords(data);
  return bech32.encode(prefix, words, Bech32MaxSize);
}
function encodeBytes(prefix, bytes) {
  return encodeBech32(prefix, bytes);
}
function nprofileEncode(profile) {
  let data = encodeTLV({
    0: [hexToBytes(profile.pubkey)],
    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))
  });
  return encodeBech32("nprofile", data);
}
function neventEncode(event) {
  let kindArray;
  if (event.kind !== void 0) {
    kindArray = integerToUint8Array(event.kind);
  }
  let data = encodeTLV({
    0: [hexToBytes(event.id)],
    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),
    2: event.author ? [hexToBytes(event.author)] : [],
    3: kindArray ? [new Uint8Array(kindArray)] : []
  });
  return encodeBech32("nevent", data);
}
function naddrEncode(addr) {
  let kind = new ArrayBuffer(4);
  new DataView(kind).setUint32(0, addr.kind, false);
  let data = encodeTLV({
    0: [utf8Encoder.encode(addr.identifier)],
    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),
    2: [hexToBytes(addr.pubkey)],
    3: [new Uint8Array(kind)]
  });
  return encodeBech32("naddr", data);
}
function encodeTLV(tlv) {
  let entries = [];
  Object.entries(tlv).reverse().forEach(([t2, vs]) => {
    vs.forEach((v4) => {
      let entry = new Uint8Array(v4.length + 2);
      entry.set([parseInt(t2)], 0);
      entry.set([v4.length], 1);
      entry.set(v4, 2);
      entries.push(entry);
    });
  });
  return concatBytes(...entries);
}
var nip04_exports = {};
__export(nip04_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt
});
function encrypt(secretKey, pubkey, text) {
  const privkey = secretKey instanceof Uint8Array ? bytesToHex(secretKey) : secretKey;
  const key = secp256k1.getSharedSecret(privkey, "02" + pubkey);
  const normalizedKey = getNormalizedX(key);
  let iv = Uint8Array.from(randomBytes(16));
  let plaintext = utf8Encoder.encode(text);
  let ciphertext = cbc(normalizedKey, iv).encrypt(plaintext);
  let ctb64 = base64.encode(new Uint8Array(ciphertext));
  let ivb64 = base64.encode(new Uint8Array(iv.buffer));
  return `${ctb64}?iv=${ivb64}`;
}
function decrypt(secretKey, pubkey, data) {
  const privkey = secretKey instanceof Uint8Array ? bytesToHex(secretKey) : secretKey;
  let [ctb64, ivb64] = data.split("?iv=");
  let key = secp256k1.getSharedSecret(privkey, "02" + pubkey);
  let normalizedKey = getNormalizedX(key);
  let iv = base64.decode(ivb64);
  let ciphertext = base64.decode(ctb64);
  let plaintext = cbc(normalizedKey, iv).decrypt(ciphertext);
  return utf8Decoder.decode(plaintext);
}
function getNormalizedX(key) {
  return key.slice(1, 33);
}
var nip05_exports = {};
__export(nip05_exports, {
  NIP05_REGEX: () => NIP05_REGEX,
  isNip05: () => isNip05,
  isValid: () => isValid,
  queryProfile: () => queryProfile,
  searchDomain: () => searchDomain,
  useFetchImplementation: () => useFetchImplementation
});
var NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/;
var isNip05 = (value) => NIP05_REGEX.test(value || "");
var _fetch;
try {
  _fetch = fetch;
} catch (_3) {
  null;
}
function useFetchImplementation(fetchImplementation) {
  _fetch = fetchImplementation;
}
async function searchDomain(domain, query = "") {
  try {
    const url = `https://${domain}/.well-known/nostr.json?name=${query}`;
    const res = await _fetch(url, { redirect: "manual" });
    if (res.status !== 200) {
      throw Error("Wrong response code");
    }
    const json = await res.json();
    return json.names;
  } catch (_3) {
    return {};
  }
}
async function queryProfile(fullname) {
  var _a;
  const match = fullname.match(NIP05_REGEX);
  if (!match)
    return null;
  const [, name = "_", domain] = match;
  try {
    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;
    const res = await _fetch(url, { redirect: "manual" });
    if (res.status !== 200) {
      throw Error("Wrong response code");
    }
    const json = await res.json();
    const pubkey = json.names[name];
    return pubkey ? { pubkey, relays: (_a = json.relays) == null ? void 0 : _a[pubkey] } : null;
  } catch (_e) {
    return null;
  }
}
async function isValid(pubkey, nip05) {
  const res = await queryProfile(nip05);
  return res ? res.pubkey === pubkey : false;
}
var nip10_exports = {};
__export(nip10_exports, {
  parse: () => parse
});
function parse(event) {
  const result = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: [],
    quotes: []
  };
  let maybeParent;
  let maybeRoot;
  for (let i22 = event.tags.length - 1; i22 >= 0; i22--) {
    const tag = event.tags[i22];
    if (tag[0] === "e" && tag[1]) {
      const [_3, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag;
      const eventPointer = {
        id: eTagEventId,
        relays: eTagRelayUrl ? [eTagRelayUrl] : [],
        author: eTagAuthor
      };
      if (eTagMarker === "root") {
        result.root = eventPointer;
        continue;
      }
      if (eTagMarker === "reply") {
        result.reply = eventPointer;
        continue;
      }
      if (eTagMarker === "mention") {
        result.mentions.push(eventPointer);
        continue;
      }
      if (!maybeParent) {
        maybeParent = eventPointer;
      } else {
        maybeRoot = eventPointer;
      }
      result.mentions.push(eventPointer);
      continue;
    }
    if (tag[0] === "q" && tag[1]) {
      const [_3, eTagEventId, eTagRelayUrl] = tag;
      result.quotes.push({
        id: eTagEventId,
        relays: eTagRelayUrl ? [eTagRelayUrl] : []
      });
    }
    if (tag[0] === "p" && tag[1]) {
      result.profiles.push({
        pubkey: tag[1],
        relays: tag[2] ? [tag[2]] : []
      });
      continue;
    }
  }
  if (!result.root) {
    result.root = maybeRoot || maybeParent || result.reply;
  }
  if (!result.reply) {
    result.reply = maybeParent || result.root;
  }
  ;
  [result.reply, result.root].forEach((ref) => {
    if (!ref)
      return;
    let idx = result.mentions.indexOf(ref);
    if (idx !== -1) {
      result.mentions.splice(idx, 1);
    }
    if (ref.author) {
      let author = result.profiles.find((p3) => p3.pubkey === ref.author);
      if (author && author.relays) {
        if (!ref.relays) {
          ref.relays = [];
        }
        author.relays.forEach((url) => {
          var _a;
          if (((_a = ref.relays) == null ? void 0 : _a.indexOf(url)) === -1)
            ref.relays.push(url);
        });
        author.relays = ref.relays;
      }
    }
  });
  result.mentions.forEach((ref) => {
    if (ref.author) {
      let author = result.profiles.find((p3) => p3.pubkey === ref.author);
      if (author && author.relays) {
        if (!ref.relays) {
          ref.relays = [];
        }
        author.relays.forEach((url) => {
          if (ref.relays.indexOf(url) === -1)
            ref.relays.push(url);
        });
        author.relays = ref.relays;
      }
    }
  });
  return result;
}
var nip11_exports = {};
__export(nip11_exports, {
  fetchRelayInformation: () => fetchRelayInformation,
  useFetchImplementation: () => useFetchImplementation2
});
var _fetch2;
try {
  _fetch2 = fetch;
} catch {
}
function useFetchImplementation2(fetchImplementation) {
  _fetch2 = fetchImplementation;
}
async function fetchRelayInformation(url) {
  return await (await fetch(url.replace("ws://", "http://").replace("wss://", "https://"), {
    headers: { Accept: "application/nostr+json" }
  })).json();
}
var nip13_exports = {};
__export(nip13_exports, {
  fastEventHash: () => fastEventHash,
  getPow: () => getPow,
  minePow: () => minePow
});
function getPow(hex) {
  let count = 0;
  for (let i22 = 0; i22 < 64; i22 += 8) {
    const nibble = parseInt(hex.substring(i22, i22 + 8), 16);
    if (nibble === 0) {
      count += 32;
    } else {
      count += Math.clz32(nibble);
      break;
    }
  }
  return count;
}
function minePow(unsigned, difficulty) {
  let count = 0;
  const event = unsigned;
  const tag = ["nonce", count.toString(), difficulty.toString()];
  event.tags.push(tag);
  while (true) {
    const now2 = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (now2 !== event.created_at) {
      count = 0;
      event.created_at = now2;
    }
    tag[1] = (++count).toString();
    event.id = fastEventHash(event);
    if (getPow(event.id) >= difficulty) {
      break;
    }
  }
  return event;
}
function fastEventHash(evt) {
  return bytesToHex(
    sha256(utf8Encoder.encode(JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])))
  );
}
var nip17_exports = {};
__export(nip17_exports, {
  unwrapEvent: () => unwrapEvent2,
  unwrapManyEvents: () => unwrapManyEvents2,
  wrapEvent: () => wrapEvent2,
  wrapManyEvents: () => wrapManyEvents2
});
var nip59_exports = {};
__export(nip59_exports, {
  createRumor: () => createRumor,
  createSeal: () => createSeal,
  createWrap: () => createWrap,
  unwrapEvent: () => unwrapEvent,
  unwrapManyEvents: () => unwrapManyEvents,
  wrapEvent: () => wrapEvent,
  wrapManyEvents: () => wrapManyEvents
});
var nip44_exports = {};
__export(nip44_exports, {
  decrypt: () => decrypt2,
  encrypt: () => encrypt2,
  getConversationKey: () => getConversationKey,
  v2: () => v2
});
var minPlaintextSize = 1;
var maxPlaintextSize = 65535;
function getConversationKey(privkeyA, pubkeyB) {
  const sharedX = secp256k1.getSharedSecret(privkeyA, "02" + pubkeyB).subarray(1, 33);
  return extract(sha256, sharedX, "nip44-v2");
}
function getMessageKeys(conversationKey, nonce) {
  const keys = expand(sha256, conversationKey, nonce, 76);
  return {
    chacha_key: keys.subarray(0, 32),
    chacha_nonce: keys.subarray(32, 44),
    hmac_key: keys.subarray(44, 76)
  };
}
function calcPaddedLen(len) {
  if (!Number.isSafeInteger(len) || len < 1)
    throw new Error("expected positive integer");
  if (len <= 32)
    return 32;
  const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;
  const chunk = nextPower <= 256 ? 32 : nextPower / 8;
  return chunk * (Math.floor((len - 1) / chunk) + 1);
}
function writeU16BE(num) {
  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)
    throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");
  const arr = new Uint8Array(2);
  new DataView(arr.buffer).setUint16(0, num, false);
  return arr;
}
function pad(plaintext) {
  const unpadded = utf8Encoder.encode(plaintext);
  const unpaddedLen = unpadded.length;
  const prefix = writeU16BE(unpaddedLen);
  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);
  return concatBytes(prefix, unpadded, suffix);
}
function unpad(padded) {
  const unpaddedLen = new DataView(padded.buffer).getUint16(0);
  const unpadded = padded.subarray(2, 2 + unpaddedLen);
  if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))
    throw new Error("invalid padding");
  return utf8Decoder.decode(unpadded);
}
function hmacAad(key, message, aad) {
  if (aad.length !== 32)
    throw new Error("AAD associated data must be 32 bytes");
  const combined = concatBytes(aad, message);
  return hmac(sha256, key, combined);
}
function decodePayload(payload) {
  if (typeof payload !== "string")
    throw new Error("payload must be a valid string");
  const plen = payload.length;
  if (plen < 132 || plen > 87472)
    throw new Error("invalid payload length: " + plen);
  if (payload[0] === "#")
    throw new Error("unknown encryption version");
  let data;
  try {
    data = base64.decode(payload);
  } catch (error) {
    throw new Error("invalid base64: " + error.message);
  }
  const dlen = data.length;
  if (dlen < 99 || dlen > 65603)
    throw new Error("invalid data length: " + dlen);
  const vers = data[0];
  if (vers !== 2)
    throw new Error("unknown encryption version " + vers);
  return {
    nonce: data.subarray(1, 33),
    ciphertext: data.subarray(33, -32),
    mac: data.subarray(-32)
  };
}
function encrypt2(plaintext, conversationKey, nonce = randomBytes(32)) {
  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);
  const padded = pad(plaintext);
  const ciphertext = chacha20(chacha_key, chacha_nonce, padded);
  const mac = hmacAad(hmac_key, ciphertext, nonce);
  return base64.encode(concatBytes(new Uint8Array([2]), nonce, ciphertext, mac));
}
function decrypt2(payload, conversationKey) {
  const { nonce, ciphertext, mac } = decodePayload(payload);
  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);
  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);
  if (!equalBytes(calculatedMac, mac))
    throw new Error("invalid MAC");
  const padded = chacha20(chacha_key, chacha_nonce, ciphertext);
  return unpad(padded);
}
var v2 = {
  utils: {
    getConversationKey,
    calcPaddedLen
  },
  encrypt: encrypt2,
  decrypt: decrypt2
};
var TWO_DAYS = 2 * 24 * 60 * 60;
var now = () => Math.round(Date.now() / 1e3);
var randomNow = () => Math.round(now() - Math.random() * TWO_DAYS);
var nip44ConversationKey = (privateKey, publicKey) => getConversationKey(privateKey, publicKey);
var nip44Encrypt = (data, privateKey, publicKey) => encrypt2(JSON.stringify(data), nip44ConversationKey(privateKey, publicKey));
var nip44Decrypt = (data, privateKey) => JSON.parse(decrypt2(data.content, nip44ConversationKey(privateKey, data.pubkey)));
function createRumor(event, privateKey) {
  const rumor = {
    created_at: now(),
    content: "",
    tags: [],
    ...event,
    pubkey: getPublicKey(privateKey)
  };
  rumor.id = getEventHash(rumor);
  return rumor;
}
function createSeal(rumor, privateKey, recipientPublicKey) {
  return finalizeEvent(
    {
      kind: Seal,
      content: nip44Encrypt(rumor, privateKey, recipientPublicKey),
      created_at: randomNow(),
      tags: []
    },
    privateKey
  );
}
function createWrap(seal, recipientPublicKey) {
  const randomKey = generateSecretKey();
  return finalizeEvent(
    {
      kind: GiftWrap,
      content: nip44Encrypt(seal, randomKey, recipientPublicKey),
      created_at: randomNow(),
      tags: [["p", recipientPublicKey]]
    },
    randomKey
  );
}
function wrapEvent(event, senderPrivateKey, recipientPublicKey) {
  const rumor = createRumor(event, senderPrivateKey);
  const seal = createSeal(rumor, senderPrivateKey, recipientPublicKey);
  return createWrap(seal, recipientPublicKey);
}
function wrapManyEvents(event, senderPrivateKey, recipientsPublicKeys) {
  if (!recipientsPublicKeys || recipientsPublicKeys.length === 0) {
    throw new Error("At least one recipient is required.");
  }
  const senderPublicKey = getPublicKey(senderPrivateKey);
  const wrappeds = [wrapEvent(event, senderPrivateKey, senderPublicKey)];
  recipientsPublicKeys.forEach((recipientPublicKey) => {
    wrappeds.push(wrapEvent(event, senderPrivateKey, recipientPublicKey));
  });
  return wrappeds;
}
function unwrapEvent(wrap, recipientPrivateKey) {
  const unwrappedSeal = nip44Decrypt(wrap, recipientPrivateKey);
  return nip44Decrypt(unwrappedSeal, recipientPrivateKey);
}
function unwrapManyEvents(wrappedEvents, recipientPrivateKey) {
  let unwrappedEvents = [];
  wrappedEvents.forEach((e2) => {
    unwrappedEvents.push(unwrapEvent(e2, recipientPrivateKey));
  });
  unwrappedEvents.sort((a2, b3) => a2.created_at - b3.created_at);
  return unwrappedEvents;
}
function createEvent(recipients, message, conversationTitle, replyTo) {
  const baseEvent = {
    created_at: Math.ceil(Date.now() / 1e3),
    kind: PrivateDirectMessage,
    tags: [],
    content: message
  };
  const recipientsArray = Array.isArray(recipients) ? recipients : [recipients];
  recipientsArray.forEach(({ publicKey, relayUrl }) => {
    baseEvent.tags.push(relayUrl ? ["p", publicKey, relayUrl] : ["p", publicKey]);
  });
  if (replyTo) {
    baseEvent.tags.push(["e", replyTo.eventId, replyTo.relayUrl || "", "reply"]);
  }
  if (conversationTitle) {
    baseEvent.tags.push(["subject", conversationTitle]);
  }
  return baseEvent;
}
function wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo) {
  const event = createEvent(recipient, message, conversationTitle, replyTo);
  return wrapEvent(event, senderPrivateKey, recipient.publicKey);
}
function wrapManyEvents2(senderPrivateKey, recipients, message, conversationTitle, replyTo) {
  if (!recipients || recipients.length === 0) {
    throw new Error("At least one recipient is required.");
  }
  const senderPublicKey = getPublicKey(senderPrivateKey);
  return [{ publicKey: senderPublicKey }, ...recipients].map(
    (recipient) => wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo)
  );
}
var unwrapEvent2 = unwrapEvent;
var unwrapManyEvents2 = unwrapManyEvents;
var nip18_exports = {};
__export(nip18_exports, {
  finishRepostEvent: () => finishRepostEvent,
  getRepostedEvent: () => getRepostedEvent,
  getRepostedEventPointer: () => getRepostedEventPointer
});
function finishRepostEvent(t2, reposted, relayUrl, privateKey) {
  var _a;
  let kind;
  const tags = [...t2.tags ?? [], ["e", reposted.id, relayUrl], ["p", reposted.pubkey]];
  if (reposted.kind === ShortTextNote) {
    kind = Repost;
  } else {
    kind = GenericRepost;
    tags.push(["k", String(reposted.kind)]);
  }
  return finalizeEvent(
    {
      kind,
      tags,
      content: t2.content === "" || ((_a = reposted.tags) == null ? void 0 : _a.find((tag) => tag[0] === "-")) ? "" : JSON.stringify(reposted),
      created_at: t2.created_at
    },
    privateKey
  );
}
function getRepostedEventPointer(event) {
  if (![Repost, GenericRepost].includes(event.kind)) {
    return void 0;
  }
  let lastETag;
  let lastPTag;
  for (let i22 = event.tags.length - 1; i22 >= 0 && (lastETag === void 0 || lastPTag === void 0); i22--) {
    const tag = event.tags[i22];
    if (tag.length >= 2) {
      if (tag[0] === "e" && lastETag === void 0) {
        lastETag = tag;
      } else if (tag[0] === "p" && lastPTag === void 0) {
        lastPTag = tag;
      }
    }
  }
  if (lastETag === void 0) {
    return void 0;
  }
  return {
    id: lastETag[1],
    relays: [lastETag[2], lastPTag == null ? void 0 : lastPTag[2]].filter((x3) => typeof x3 === "string"),
    author: lastPTag == null ? void 0 : lastPTag[1]
  };
}
function getRepostedEvent(event, { skipVerification } = {}) {
  const pointer = getRepostedEventPointer(event);
  if (pointer === void 0 || event.content === "") {
    return void 0;
  }
  let repostedEvent;
  try {
    repostedEvent = JSON.parse(event.content);
  } catch (error) {
    return void 0;
  }
  if (repostedEvent.id !== pointer.id) {
    return void 0;
  }
  if (!skipVerification && !verifyEvent(repostedEvent)) {
    return void 0;
  }
  return repostedEvent;
}
var nip21_exports = {};
__export(nip21_exports, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,
  parse: () => parse2,
  test: () => test
});
var NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);
function test(value) {
  return typeof value === "string" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);
}
function parse2(uri) {
  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));
  if (!match)
    throw new Error(`Invalid Nostr URI: ${uri}`);
  return {
    uri: match[0],
    value: match[1],
    decoded: decode(match[1])
  };
}
var nip25_exports = {};
__export(nip25_exports, {
  finishReactionEvent: () => finishReactionEvent,
  getReactedEventPointer: () => getReactedEventPointer
});
function finishReactionEvent(t2, reacted, privateKey) {
  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === "e" || tag[0] === "p"));
  return finalizeEvent(
    {
      ...t2,
      kind: Reaction,
      tags: [...t2.tags ?? [], ...inheritedTags, ["e", reacted.id], ["p", reacted.pubkey]],
      content: t2.content ?? "+"
    },
    privateKey
  );
}
function getReactedEventPointer(event) {
  if (event.kind !== Reaction) {
    return void 0;
  }
  let lastETag;
  let lastPTag;
  for (let i22 = event.tags.length - 1; i22 >= 0 && (lastETag === void 0 || lastPTag === void 0); i22--) {
    const tag = event.tags[i22];
    if (tag.length >= 2) {
      if (tag[0] === "e" && lastETag === void 0) {
        lastETag = tag;
      } else if (tag[0] === "p" && lastPTag === void 0) {
        lastPTag = tag;
      }
    }
  }
  if (lastETag === void 0 || lastPTag === void 0) {
    return void 0;
  }
  return {
    id: lastETag[1],
    relays: [lastETag[2], lastPTag[2]].filter((x3) => x3 !== void 0),
    author: lastPTag[1]
  };
}
var nip27_exports = {};
__export(nip27_exports, {
  parse: () => parse3
});
var noCharacter = /\W/m;
var noURLCharacter = /\W |\W$|$|,| /m;
function* parse3(content) {
  const max = content.length;
  let prevIndex = 0;
  let index = 0;
  while (index < max) {
    let u2 = content.indexOf(":", index);
    if (u2 === -1) {
      break;
    }
    if (content.substring(u2 - 5, u2) === "nostr") {
      const m3 = content.substring(u2 + 60).match(noCharacter);
      const end = m3 ? u2 + 60 + m3.index : max;
      try {
        let pointer;
        let { data, type } = decode(content.substring(u2 + 1, end));
        switch (type) {
          case "npub":
            pointer = { pubkey: data };
            break;
          case "nsec":
          case "note":
            index = end + 1;
            continue;
          default:
            pointer = data;
        }
        if (prevIndex !== u2 - 5) {
          yield { type: "text", text: content.substring(prevIndex, u2 - 5) };
        }
        yield { type: "reference", pointer };
        index = end;
        prevIndex = index;
        continue;
      } catch (_err) {
        index = u2 + 1;
        continue;
      }
    } else if (content.substring(u2 - 5, u2) === "https" || content.substring(u2 - 4, u2) === "http") {
      const m3 = content.substring(u2 + 4).match(noURLCharacter);
      const end = m3 ? u2 + 4 + m3.index : max;
      const prefixLen = content[u2 - 1] === "s" ? 5 : 4;
      try {
        let url = new URL(content.substring(u2 - prefixLen, end));
        if (url.hostname.indexOf(".") === -1) {
          throw new Error("invalid url");
        }
        if (prevIndex !== u2 - prefixLen) {
          yield { type: "text", text: content.substring(prevIndex, u2 - prefixLen) };
        }
        if (url.pathname.endsWith(".png") || url.pathname.endsWith(".jpg") || url.pathname.endsWith(".jpeg") || url.pathname.endsWith(".gif") || url.pathname.endsWith(".webp")) {
          yield { type: "image", url: url.toString() };
          index = end;
          prevIndex = index;
          continue;
        }
        if (url.pathname.endsWith(".mp4") || url.pathname.endsWith(".avi") || url.pathname.endsWith(".webm") || url.pathname.endsWith(".mkv")) {
          yield { type: "video", url: url.toString() };
          index = end;
          prevIndex = index;
          continue;
        }
        if (url.pathname.endsWith(".mp3") || url.pathname.endsWith(".aac") || url.pathname.endsWith(".ogg") || url.pathname.endsWith(".opus")) {
          yield { type: "audio", url: url.toString() };
          index = end;
          prevIndex = index;
          continue;
        }
        yield { type: "url", url: url.toString() };
        index = end;
        prevIndex = index;
        continue;
      } catch (_err) {
        index = end + 1;
        continue;
      }
    } else if (content.substring(u2 - 3, u2) === "wss" || content.substring(u2 - 2, u2) === "ws") {
      const m3 = content.substring(u2 + 4).match(noURLCharacter);
      const end = m3 ? u2 + 4 + m3.index : max;
      const prefixLen = content[u2 - 1] === "s" ? 3 : 2;
      try {
        let url = new URL(content.substring(u2 - prefixLen, end));
        if (url.hostname.indexOf(".") === -1) {
          throw new Error("invalid ws url");
        }
        if (prevIndex !== u2 - prefixLen) {
          yield { type: "text", text: content.substring(prevIndex, u2 - prefixLen) };
        }
        yield { type: "relay", url: url.toString() };
        index = end;
        prevIndex = index;
        continue;
      } catch (_err) {
        index = end + 1;
        continue;
      }
    } else {
      index = u2 + 1;
      continue;
    }
  }
  if (prevIndex !== max) {
    yield { type: "text", text: content.substring(prevIndex) };
  }
}
var nip28_exports = {};
__export(nip28_exports, {
  channelCreateEvent: () => channelCreateEvent,
  channelHideMessageEvent: () => channelHideMessageEvent,
  channelMessageEvent: () => channelMessageEvent,
  channelMetadataEvent: () => channelMetadataEvent,
  channelMuteUserEvent: () => channelMuteUserEvent
});
var channelCreateEvent = (t2, privateKey) => {
  let content;
  if (typeof t2.content === "object") {
    content = JSON.stringify(t2.content);
  } else if (typeof t2.content === "string") {
    content = t2.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelCreation,
      tags: [...t2.tags ?? []],
      content,
      created_at: t2.created_at
    },
    privateKey
  );
};
var channelMetadataEvent = (t2, privateKey) => {
  let content;
  if (typeof t2.content === "object") {
    content = JSON.stringify(t2.content);
  } else if (typeof t2.content === "string") {
    content = t2.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelMetadata,
      tags: [["e", t2.channel_create_event_id], ...t2.tags ?? []],
      content,
      created_at: t2.created_at
    },
    privateKey
  );
};
var channelMessageEvent = (t2, privateKey) => {
  const tags = [["e", t2.channel_create_event_id, t2.relay_url, "root"]];
  if (t2.reply_to_channel_message_event_id) {
    tags.push(["e", t2.reply_to_channel_message_event_id, t2.relay_url, "reply"]);
  }
  return finalizeEvent(
    {
      kind: ChannelMessage,
      tags: [...tags, ...t2.tags ?? []],
      content: t2.content,
      created_at: t2.created_at
    },
    privateKey
  );
};
var channelHideMessageEvent = (t2, privateKey) => {
  let content;
  if (typeof t2.content === "object") {
    content = JSON.stringify(t2.content);
  } else if (typeof t2.content === "string") {
    content = t2.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelHideMessage,
      tags: [["e", t2.channel_message_event_id], ...t2.tags ?? []],
      content,
      created_at: t2.created_at
    },
    privateKey
  );
};
var channelMuteUserEvent = (t2, privateKey) => {
  let content;
  if (typeof t2.content === "object") {
    content = JSON.stringify(t2.content);
  } else if (typeof t2.content === "string") {
    content = t2.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelMuteUser,
      tags: [["p", t2.pubkey_to_mute], ...t2.tags ?? []],
      content,
      created_at: t2.created_at
    },
    privateKey
  );
};
var nip30_exports = {};
__export(nip30_exports, {
  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,
  matchAll: () => matchAll,
  regex: () => regex,
  replaceAll: () => replaceAll
});
var EMOJI_SHORTCODE_REGEX = /:(\w+):/;
var regex = () => new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`, "g");
function* matchAll(content) {
  const matches = content.matchAll(regex());
  for (const match of matches) {
    try {
      const [shortcode, name] = match;
      yield {
        shortcode,
        name,
        start: match.index,
        end: match.index + shortcode.length
      };
    } catch (_e) {
    }
  }
}
function replaceAll(content, replacer) {
  return content.replaceAll(regex(), (shortcode, name) => {
    return replacer({
      shortcode,
      name
    });
  });
}
var nip39_exports = {};
__export(nip39_exports, {
  useFetchImplementation: () => useFetchImplementation3,
  validateGithub: () => validateGithub
});
var _fetch3;
try {
  _fetch3 = fetch;
} catch {
}
function useFetchImplementation3(fetchImplementation) {
  _fetch3 = fetchImplementation;
}
async function validateGithub(pubkey, username, proof) {
  try {
    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();
    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;
  } catch (_3) {
    return false;
  }
}
var nip47_exports = {};
__export(nip47_exports, {
  makeNwcRequestEvent: () => makeNwcRequestEvent,
  parseConnectionString: () => parseConnectionString
});
function parseConnectionString(connectionString) {
  const { pathname, searchParams } = new URL(connectionString);
  const pubkey = pathname;
  const relay = searchParams.get("relay");
  const secret = searchParams.get("secret");
  if (!pubkey || !relay || !secret) {
    throw new Error("invalid connection string");
  }
  return { pubkey, relay, secret };
}
async function makeNwcRequestEvent(pubkey, secretKey, invoice) {
  const content = {
    method: "pay_invoice",
    params: {
      invoice
    }
  };
  const encryptedContent = encrypt(secretKey, pubkey, JSON.stringify(content));
  const eventTemplate = {
    kind: NWCWalletRequest,
    created_at: Math.round(Date.now() / 1e3),
    content: encryptedContent,
    tags: [["p", pubkey]]
  };
  return finalizeEvent(eventTemplate, secretKey);
}
var nip54_exports = {};
__export(nip54_exports, {
  normalizeIdentifier: () => normalizeIdentifier
});
function normalizeIdentifier(name) {
  name = name.trim().toLowerCase();
  name = name.normalize("NFKC");
  return Array.from(name).map((char) => {
    if (new RegExp("\\p{Letter}", "u").test(char) || new RegExp("\\p{Number}", "u").test(char)) {
      return char;
    }
    return "-";
  }).join("");
}
var nip57_exports = {};
__export(nip57_exports, {
  getSatoshisAmountFromBolt11: () => getSatoshisAmountFromBolt11,
  getZapEndpoint: () => getZapEndpoint,
  makeZapReceipt: () => makeZapReceipt,
  makeZapRequest: () => makeZapRequest,
  useFetchImplementation: () => useFetchImplementation4,
  validateZapRequest: () => validateZapRequest
});
var _fetch4;
try {
  _fetch4 = fetch;
} catch {
}
function useFetchImplementation4(fetchImplementation) {
  _fetch4 = fetchImplementation;
}
async function getZapEndpoint(metadata) {
  try {
    let lnurl = "";
    let { lud06, lud16 } = JSON.parse(metadata.content);
    if (lud06) {
      let { words } = bech32.decode(lud06, 1e3);
      let data = bech32.fromWords(words);
      lnurl = utf8Decoder.decode(data);
    } else if (lud16) {
      let [name, domain] = lud16.split("@");
      lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();
    } else {
      return null;
    }
    let res = await _fetch4(lnurl);
    let body = await res.json();
    if (body.allowsNostr && body.nostrPubkey) {
      return body.callback;
    }
  } catch (err) {
  }
  return null;
}
function makeZapRequest({
  profile,
  event,
  amount,
  relays,
  comment = ""
}) {
  if (!amount)
    throw new Error("amount not given");
  if (!profile)
    throw new Error("profile not given");
  let zr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: comment,
    tags: [
      ["p", profile],
      ["amount", amount.toString()],
      ["relays", ...relays]
    ]
  };
  if (event && typeof event === "string") {
    zr.tags.push(["e", event]);
  }
  if (event && typeof event === "object") {
    if (isReplaceableKind(event.kind)) {
      const a2 = ["a", `${event.kind}:${event.pubkey}:`];
      zr.tags.push(a2);
    } else if (isAddressableKind(event.kind)) {
      let d3 = event.tags.find(([t2, v4]) => t2 === "d" && v4);
      if (!d3)
        throw new Error("d tag not found or is empty");
      const a2 = ["a", `${event.kind}:${event.pubkey}:${d3[1]}`];
      zr.tags.push(a2);
    }
  }
  return zr;
}
function validateZapRequest(zapRequestString) {
  let zapRequest;
  try {
    zapRequest = JSON.parse(zapRequestString);
  } catch (err) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent(zapRequest))
    return "Zap request is not a valid Nostr event.";
  if (!verifyEvent(zapRequest))
    return "Invalid signature on zap request.";
  let p3 = zapRequest.tags.find(([t2, v4]) => t2 === "p" && v4);
  if (!p3)
    return "Zap request doesn't have a 'p' tag.";
  if (!p3[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let e2 = zapRequest.tags.find(([t2, v4]) => t2 === "e" && v4);
  if (e2 && !e2[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'e' tag is not valid hex.";
  let relays = zapRequest.tags.find(([t2, v4]) => t2 === "relays" && v4);
  if (!relays)
    return "Zap request doesn't have a 'relays' tag.";
  return null;
}
function makeZapReceipt({
  zapRequest,
  preimage,
  bolt11,
  paidAt
}) {
  let zr = JSON.parse(zapRequest);
  let tagsFromZapRequest = zr.tags.filter(([t2]) => t2 === "e" || t2 === "p" || t2 === "a");
  let zap = {
    kind: 9735,
    created_at: Math.round(paidAt.getTime() / 1e3),
    content: "",
    tags: [...tagsFromZapRequest, ["P", zr.pubkey], ["bolt11", bolt11], ["description", zapRequest]]
  };
  if (preimage) {
    zap.tags.push(["preimage", preimage]);
  }
  return zap;
}
function getSatoshisAmountFromBolt11(bolt11) {
  if (bolt11.length < 50) {
    return 0;
  }
  bolt11 = bolt11.substring(0, 50);
  const idx = bolt11.lastIndexOf("1");
  if (idx === -1) {
    return 0;
  }
  const hrp = bolt11.substring(0, idx);
  if (!hrp.startsWith("lnbc")) {
    return 0;
  }
  const amount = hrp.substring(4);
  if (amount.length < 1) {
    return 0;
  }
  const char = amount[amount.length - 1];
  const digit = char.charCodeAt(0) - "0".charCodeAt(0);
  const isDigit = digit >= 0 && digit <= 9;
  let cutPoint = amount.length - 1;
  if (isDigit) {
    cutPoint++;
  }
  if (cutPoint < 1) {
    return 0;
  }
  const num = parseInt(amount.substring(0, cutPoint));
  switch (char) {
    case "m":
      return num * 1e5;
    case "u":
      return num * 100;
    case "n":
      return num / 10;
    case "p":
      return num / 1e4;
    default:
      return num * 1e8;
  }
}
var nip98_exports = {};
__export(nip98_exports, {
  getToken: () => getToken,
  hashPayload: () => hashPayload,
  unpackEventFromToken: () => unpackEventFromToken,
  validateEvent: () => validateEvent2,
  validateEventKind: () => validateEventKind,
  validateEventMethodTag: () => validateEventMethodTag,
  validateEventPayloadTag: () => validateEventPayloadTag,
  validateEventTimestamp: () => validateEventTimestamp,
  validateEventUrlTag: () => validateEventUrlTag,
  validateToken: () => validateToken
});
var _authorizationScheme = "Nostr ";
async function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {
  const event = {
    kind: HTTPAuth,
    tags: [
      ["u", loginUrl],
      ["method", httpMethod]
    ],
    created_at: Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3),
    content: ""
  };
  if (payload) {
    event.tags.push(["payload", hashPayload(payload)]);
  }
  const signedEvent = await sign(event);
  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : "";
  return authorizationScheme + base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));
}
async function validateToken(token, url, method) {
  const event = await unpackEventFromToken(token).catch((error) => {
    throw error;
  });
  const valid = await validateEvent2(event, url, method).catch((error) => {
    throw error;
  });
  return valid;
}
async function unpackEventFromToken(token) {
  if (!token) {
    throw new Error("Missing token");
  }
  token = token.replace(_authorizationScheme, "");
  const eventB64 = utf8Decoder.decode(base64.decode(token));
  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith("{")) {
    throw new Error("Invalid token");
  }
  const event = JSON.parse(eventB64);
  return event;
}
function validateEventTimestamp(event) {
  if (!event.created_at) {
    return false;
  }
  return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - event.created_at < 60;
}
function validateEventKind(event) {
  return event.kind === HTTPAuth;
}
function validateEventUrlTag(event, url) {
  const urlTag = event.tags.find((t2) => t2[0] === "u");
  if (!urlTag) {
    return false;
  }
  return urlTag.length > 0 && urlTag[1] === url;
}
function validateEventMethodTag(event, method) {
  const methodTag = event.tags.find((t2) => t2[0] === "method");
  if (!methodTag) {
    return false;
  }
  return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();
}
function hashPayload(payload) {
  const hash = sha256(utf8Encoder.encode(JSON.stringify(payload)));
  return bytesToHex(hash);
}
function validateEventPayloadTag(event, payload) {
  const payloadTag = event.tags.find((t2) => t2[0] === "payload");
  if (!payloadTag) {
    return false;
  }
  const payloadHash = hashPayload(payload);
  return payloadTag.length > 0 && payloadTag[1] === payloadHash;
}
async function validateEvent2(event, url, method, body) {
  if (!verifyEvent(event)) {
    throw new Error("Invalid nostr event, signature invalid");
  }
  if (!validateEventKind(event)) {
    throw new Error("Invalid nostr event, kind invalid");
  }
  if (!validateEventTimestamp(event)) {
    throw new Error("Invalid nostr event, created_at timestamp invalid");
  }
  if (!validateEventUrlTag(event, url)) {
    throw new Error("Invalid nostr event, url tag invalid");
  }
  if (!validateEventMethodTag(event, method)) {
    throw new Error("Invalid nostr event, method tag invalid");
  }
  if (Boolean(body) && typeof body === "object" && Object.keys(body).length > 0) {
    if (!validateEventPayloadTag(event, body)) {
      throw new Error("Invalid nostr event, payload tag does not match request body hash");
    }
  }
  return true;
}

// node_modules/.pnpm/@getalby+lightning-tools@5.2.1/node_modules/@getalby/lightning-tools/dist/index.modern.js
var e;
var t;
var r = (e = function(e2, t2) {
  function r2(e3) {
    if (!Number.isSafeInteger(e3)) throw new Error(`Wrong integer: ${e3}`);
  }
  function n2(...e3) {
    const t3 = (e4, t4) => (r3) => e4(t4(r3));
    return { encode: Array.from(e3).reverse().reduce((e4, r3) => e4 ? t3(e4, r3.encode) : r3.encode, void 0), decode: e3.reduce((e4, r3) => e4 ? t3(e4, r3.decode) : r3.decode, void 0) };
  }
  function o2(e3) {
    return { encode: (t3) => {
      if (!Array.isArray(t3) || t3.length && "number" != typeof t3[0]) throw new Error("alphabet.encode input should be an array of numbers");
      return t3.map((t4) => {
        if (r2(t4), t4 < 0 || t4 >= e3.length) throw new Error(`Digit index outside alphabet: ${t4} (alphabet: ${e3.length})`);
        return e3[t4];
      });
    }, decode: (t3) => {
      if (!Array.isArray(t3) || t3.length && "string" != typeof t3[0]) throw new Error("alphabet.decode input should be array of strings");
      return t3.map((t4) => {
        if ("string" != typeof t4) throw new Error(`alphabet.decode: not string element=${t4}`);
        const r3 = e3.indexOf(t4);
        if (-1 === r3) throw new Error(`Unknown letter: "${t4}". Allowed: ${e3}`);
        return r3;
      });
    } };
  }
  function s2(e3 = "") {
    if ("string" != typeof e3) throw new Error("join separator should be string");
    return { encode: (t3) => {
      if (!Array.isArray(t3) || t3.length && "string" != typeof t3[0]) throw new Error("join.encode input should be array of strings");
      for (let e4 of t3) if ("string" != typeof e4) throw new Error(`join.encode: non-string input=${e4}`);
      return t3.join(e3);
    }, decode: (t3) => {
      if ("string" != typeof t3) throw new Error("join.decode input should be string");
      return t3.split(e3);
    } };
  }
  function i3(e3, t3 = "=") {
    if (r2(e3), "string" != typeof t3) throw new Error("padding chr should be string");
    return { encode(r3) {
      if (!Array.isArray(r3) || r3.length && "string" != typeof r3[0]) throw new Error("padding.encode input should be array of strings");
      for (let e4 of r3) if ("string" != typeof e4) throw new Error(`padding.encode: non-string input=${e4}`);
      for (; r3.length * e3 % 8; ) r3.push(t3);
      return r3;
    }, decode(r3) {
      if (!Array.isArray(r3) || r3.length && "string" != typeof r3[0]) throw new Error("padding.encode input should be array of strings");
      for (let e4 of r3) if ("string" != typeof e4) throw new Error(`padding.decode: non-string input=${e4}`);
      let n3 = r3.length;
      if (n3 * e3 % 8) throw new Error("Invalid padding: string should have whole number of bytes");
      for (; n3 > 0 && r3[n3 - 1] === t3; n3--) if (!((n3 - 1) * e3 % 8)) throw new Error("Invalid padding: string has too much padding");
      return r3.slice(0, n3);
    } };
  }
  function a2(e3) {
    if ("function" != typeof e3) throw new Error("normalize fn should be function");
    return { encode: (e4) => e4, decode: (t3) => e3(t3) };
  }
  function c2(e3, t3, n3) {
    if (t3 < 2) throw new Error(`convertRadix: wrong from=${t3}, base cannot be less than 2`);
    if (n3 < 2) throw new Error(`convertRadix: wrong to=${n3}, base cannot be less than 2`);
    if (!Array.isArray(e3)) throw new Error("convertRadix: data should be array");
    if (!e3.length) return [];
    let o3 = 0;
    const s3 = [], i4 = Array.from(e3);
    for (i4.forEach((e4) => {
      if (r2(e4), e4 < 0 || e4 >= t3) throw new Error(`Wrong integer: ${e4}`);
    }); ; ) {
      let e4 = 0, r3 = true;
      for (let s4 = o3; s4 < i4.length; s4++) {
        const a3 = i4[s4], c3 = t3 * e4 + a3;
        if (!Number.isSafeInteger(c3) || t3 * e4 / t3 !== e4 || c3 - a3 != t3 * e4) throw new Error("convertRadix: carry overflow");
        if (e4 = c3 % n3, i4[s4] = Math.floor(c3 / n3), !Number.isSafeInteger(i4[s4]) || i4[s4] * n3 + e4 !== c3) throw new Error("convertRadix: carry overflow");
        r3 && (i4[s4] ? r3 = false : o3 = s4);
      }
      if (s3.push(e4), r3) break;
    }
    for (let t4 = 0; t4 < e3.length - 1 && 0 === e3[t4]; t4++) s3.push(0);
    return s3.reverse();
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.bytes = t2.stringToBytes = t2.str = t2.bytesToString = t2.hex = t2.utf8 = t2.bech32m = t2.bech32 = t2.base58check = t2.base58xmr = t2.base58xrp = t2.base58flickr = t2.base58 = t2.base64url = t2.base64 = t2.base32crockford = t2.base32hex = t2.base32 = t2.base16 = t2.utils = t2.assertNumber = void 0, t2.assertNumber = r2;
  const h3 = (e3, t3) => t3 ? h3(t3, e3 % t3) : e3, l2 = (e3, t3) => e3 + (t3 - h3(e3, t3));
  function u2(e3, t3, n3, o3) {
    if (!Array.isArray(e3)) throw new Error("convertRadix2: data should be array");
    if (t3 <= 0 || t3 > 32) throw new Error(`convertRadix2: wrong from=${t3}`);
    if (n3 <= 0 || n3 > 32) throw new Error(`convertRadix2: wrong to=${n3}`);
    if (l2(t3, n3) > 32) throw new Error(`convertRadix2: carry overflow from=${t3} to=${n3} carryBits=${l2(t3, n3)}`);
    let s3 = 0, i4 = 0;
    const a3 = 2 ** n3 - 1, c3 = [];
    for (const o4 of e3) {
      if (r2(o4), o4 >= 2 ** t3) throw new Error(`convertRadix2: invalid data word=${o4} from=${t3}`);
      if (s3 = s3 << t3 | o4, i4 + t3 > 32) throw new Error(`convertRadix2: carry overflow pos=${i4} from=${t3}`);
      for (i4 += t3; i4 >= n3; i4 -= n3) c3.push((s3 >> i4 - n3 & a3) >>> 0);
      s3 &= 2 ** i4 - 1;
    }
    if (s3 = s3 << n3 - i4 & a3, !o3 && i4 >= t3) throw new Error("Excess padding");
    if (!o3 && s3) throw new Error(`Non-zero padding: ${s3}`);
    return o3 && i4 > 0 && c3.push(s3 >>> 0), c3;
  }
  function f3(e3) {
    return r2(e3), { encode: (t3) => {
      if (!(t3 instanceof Uint8Array)) throw new Error("radix.encode input should be Uint8Array");
      return c2(Array.from(t3), 256, e3);
    }, decode: (t3) => {
      if (!Array.isArray(t3) || t3.length && "number" != typeof t3[0]) throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(c2(t3, e3, 256));
    } };
  }
  function d3(e3, t3 = false) {
    if (r2(e3), e3 <= 0 || e3 > 32) throw new Error("radix2: bits should be in (0..32]");
    if (l2(8, e3) > 32 || l2(e3, 8) > 32) throw new Error("radix2: carry overflow");
    return { encode: (r3) => {
      if (!(r3 instanceof Uint8Array)) throw new Error("radix2.encode input should be Uint8Array");
      return u2(Array.from(r3), 8, e3, !t3);
    }, decode: (r3) => {
      if (!Array.isArray(r3) || r3.length && "number" != typeof r3[0]) throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(u2(r3, e3, 8, t3));
    } };
  }
  function p3(e3) {
    if ("function" != typeof e3) throw new Error("unsafeWrapper fn should be function");
    return function(...t3) {
      try {
        return e3.apply(null, t3);
      } catch (e4) {
      }
    };
  }
  function w3(e3, t3) {
    if (r2(e3), "function" != typeof t3) throw new Error("checksum fn should be function");
    return { encode(r3) {
      if (!(r3 instanceof Uint8Array)) throw new Error("checksum.encode: input should be Uint8Array");
      const n3 = t3(r3).slice(0, e3), o3 = new Uint8Array(r3.length + e3);
      return o3.set(r3), o3.set(n3, r3.length), o3;
    }, decode(r3) {
      if (!(r3 instanceof Uint8Array)) throw new Error("checksum.decode: input should be Uint8Array");
      const n3 = r3.slice(0, -e3), o3 = t3(n3).slice(0, e3), s3 = r3.slice(-e3);
      for (let t4 = 0; t4 < e3; t4++) if (o3[t4] !== s3[t4]) throw new Error("Invalid checksum");
      return n3;
    } };
  }
  t2.utils = { alphabet: o2, chain: n2, checksum: w3, radix: f3, radix2: d3, join: s2, padding: i3 }, t2.base16 = n2(d3(4), o2("0123456789ABCDEF"), s2("")), t2.base32 = n2(d3(5), o2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), i3(5), s2("")), t2.base32hex = n2(d3(5), o2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), i3(5), s2("")), t2.base32crockford = n2(d3(5), o2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), s2(""), a2((e3) => e3.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), t2.base64 = n2(d3(6), o2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), i3(6), s2("")), t2.base64url = n2(d3(6), o2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), i3(6), s2(""));
  const y3 = (e3) => n2(f3(58), o2(e3), s2(""));
  t2.base58 = y3("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), t2.base58flickr = y3("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), t2.base58xrp = y3("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const m3 = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  t2.base58xmr = { encode(e3) {
    let r3 = "";
    for (let n3 = 0; n3 < e3.length; n3 += 8) {
      const o3 = e3.subarray(n3, n3 + 8);
      r3 += t2.base58.encode(o3).padStart(m3[o3.length], "1");
    }
    return r3;
  }, decode(e3) {
    let r3 = [];
    for (let n3 = 0; n3 < e3.length; n3 += 11) {
      const o3 = e3.slice(n3, n3 + 11), s3 = m3.indexOf(o3.length), i4 = t2.base58.decode(o3);
      for (let e4 = 0; e4 < i4.length - s3; e4++) if (0 !== i4[e4]) throw new Error("base58xmr: wrong padding");
      r3 = r3.concat(Array.from(i4.slice(i4.length - s3)));
    }
    return Uint8Array.from(r3);
  } }, t2.base58check = (e3) => n2(w3(4, (t3) => e3(e3(t3))), t2.base58);
  const g3 = n2(o2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), s2("")), b3 = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function v4(e3) {
    const t3 = e3 >> 25;
    let r3 = (33554431 & e3) << 5;
    for (let e4 = 0; e4 < b3.length; e4++) 1 == (t3 >> e4 & 1) && (r3 ^= b3[e4]);
    return r3;
  }
  function E3(e3, t3, r3 = 1) {
    const n3 = e3.length;
    let o3 = 1;
    for (let t4 = 0; t4 < n3; t4++) {
      const r4 = e3.charCodeAt(t4);
      if (r4 < 33 || r4 > 126) throw new Error(`Invalid prefix (${e3})`);
      o3 = v4(o3) ^ r4 >> 5;
    }
    o3 = v4(o3);
    for (let t4 = 0; t4 < n3; t4++) o3 = v4(o3) ^ 31 & e3.charCodeAt(t4);
    for (let e4 of t3) o3 = v4(o3) ^ e4;
    for (let e4 = 0; e4 < 6; e4++) o3 = v4(o3);
    return o3 ^= r3, g3.encode(u2([o3 % 2 ** 30], 30, 5, false));
  }
  function x3(e3) {
    const t3 = "bech32" === e3 ? 1 : 734539939, r3 = d3(5), n3 = r3.decode, o3 = r3.encode, s3 = p3(n3);
    function i4(e4, r4 = 90) {
      if ("string" != typeof e4) throw new Error("bech32.decode input should be string, not " + typeof e4);
      if (e4.length < 8 || false !== r4 && e4.length > r4) throw new TypeError(`Wrong string length: ${e4.length} (${e4}). Expected (8..${r4})`);
      const n4 = e4.toLowerCase();
      if (e4 !== n4 && e4 !== e4.toUpperCase()) throw new Error("String must be lowercase or uppercase");
      const o4 = (e4 = n4).lastIndexOf("1");
      if (0 === o4 || -1 === o4) throw new Error('Letter "1" must be present between prefix and data only');
      const s4 = e4.slice(0, o4), i5 = e4.slice(o4 + 1);
      if (i5.length < 6) throw new Error("Data must be at least 6 characters long");
      const a3 = g3.decode(i5).slice(0, -6), c3 = E3(s4, a3, t3);
      if (!i5.endsWith(c3)) throw new Error(`Invalid checksum in ${e4}: expected "${c3}"`);
      return { prefix: s4, words: a3 };
    }
    return { encode: function(e4, r4, n4 = 90) {
      if ("string" != typeof e4) throw new Error("bech32.encode prefix should be string, not " + typeof e4);
      if (!Array.isArray(r4) || r4.length && "number" != typeof r4[0]) throw new Error("bech32.encode words should be array of numbers, not " + typeof r4);
      const o4 = e4.length + 7 + r4.length;
      if (false !== n4 && o4 > n4) throw new TypeError(`Length ${o4} exceeds limit ${n4}`);
      return `${e4 = e4.toLowerCase()}1${g3.encode(r4)}${E3(e4, r4, t3)}`;
    }, decode: i4, decodeToBytes: function(e4) {
      const { prefix: t4, words: r4 } = i4(e4, false);
      return { prefix: t4, words: r4, bytes: n3(r4) };
    }, decodeUnsafe: p3(i4), fromWords: n3, fromWordsUnsafe: s3, toWords: o3 };
  }
  t2.bech32 = x3("bech32"), t2.bech32m = x3("bech32m"), t2.utf8 = { encode: (e3) => new TextDecoder().decode(e3), decode: (e3) => new TextEncoder().encode(e3) }, t2.hex = n2(d3(4), o2("0123456789abcdef"), s2(""), a2((e3) => {
    if ("string" != typeof e3 || e3.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof e3} with length ${e3.length}`);
    return e3.toLowerCase();
  }));
  const A3 = { utf8: t2.utf8, hex: t2.hex, base16: t2.base16, base32: t2.base32, base64: t2.base64, base64url: t2.base64url, base58: t2.base58, base58xmr: t2.base58xmr }, k3 = `Invalid encoding type. Available types: ${Object.keys(A3).join(", ")}`;
  t2.bytesToString = (e3, t3) => {
    if ("string" != typeof e3 || !A3.hasOwnProperty(e3)) throw new TypeError(k3);
    if (!(t3 instanceof Uint8Array)) throw new TypeError("bytesToString() expects Uint8Array");
    return A3[e3].encode(t3);
  }, t2.str = t2.bytesToString, t2.stringToBytes = (e3, t3) => {
    if (!A3.hasOwnProperty(e3)) throw new TypeError(k3);
    if ("string" != typeof t3) throw new TypeError("stringToBytes() expects string");
    return A3[e3].decode(t3);
  }, t2.bytes = t2.stringToBytes;
}, e(t = { exports: {} }, t.exports), t.exports);
var { bech32: n, hex: o, utf8: s } = r;
var i2 = { bech32: "bc", pubKeyHash: 0, scriptHash: 5, validWitnessVersions: [0] };
var a = { bech32: "tb", pubKeyHash: 111, scriptHash: 196, validWitnessVersions: [0] };
var c = { bech32: "tbs", pubKeyHash: 111, scriptHash: 196, validWitnessVersions: [0] };
var h = { bech32: "bcrt", pubKeyHash: 111, scriptHash: 196, validWitnessVersions: [0] };
var l = { bech32: "sb", pubKeyHash: 63, scriptHash: 123, validWitnessVersions: [0] };
var u = ["option_data_loss_protect", "initial_routing_sync", "option_upfront_shutdown_script", "gossip_queries", "var_onion_optin", "gossip_queries_ex", "option_static_remotekey", "payment_secret", "basic_mpp", "option_support_large_channel"];
var f = { m: BigInt(1e3), u: BigInt(1e6), n: BigInt(1e9), p: BigInt(1e12) };
var d = BigInt("2100000000000000000");
var p = BigInt(1e11);
var w = { payment_hash: 1, payment_secret: 16, description: 13, payee: 19, description_hash: 23, expiry: 6, min_final_cltv_expiry: 24, fallback_address: 9, route_hint: 3, feature_bits: 5, metadata: 27 };
var y = {};
for (let e2 = 0, t2 = Object.keys(w); e2 < t2.length; e2++) {
  const r2 = t2[e2], n2 = w[t2[e2]].toString();
  y[n2] = r2;
}
var m = { 1: (e2) => o.encode(n.fromWordsUnsafe(e2)), 16: (e2) => o.encode(n.fromWordsUnsafe(e2)), 13: (e2) => s.encode(n.fromWordsUnsafe(e2)), 19: (e2) => o.encode(n.fromWordsUnsafe(e2)), 23: (e2) => o.encode(n.fromWordsUnsafe(e2)), 27: (e2) => o.encode(n.fromWordsUnsafe(e2)), 6: b, 24: b, 3: function(e2) {
  const t2 = [];
  let r2, s2, i3, a2, c2, h3 = n.fromWordsUnsafe(e2);
  for (; h3.length > 0; ) r2 = o.encode(h3.slice(0, 33)), s2 = o.encode(h3.slice(33, 41)), i3 = parseInt(o.encode(h3.slice(41, 45)), 16), a2 = parseInt(o.encode(h3.slice(45, 49)), 16), c2 = parseInt(o.encode(h3.slice(49, 51)), 16), h3 = h3.slice(51), t2.push({ pubkey: r2, short_channel_id: s2, fee_base_msat: i3, fee_proportional_millionths: a2, cltv_expiry_delta: c2 });
  return t2;
}, 5: function(e2) {
  const t2 = e2.slice().reverse().map((e3) => [!!(1 & e3), !!(2 & e3), !!(4 & e3), !!(8 & e3), !!(16 & e3)]).reduce((e3, t3) => e3.concat(t3), []);
  for (; t2.length < 2 * u.length; ) t2.push(false);
  const r2 = {};
  u.forEach((e3, n3) => {
    let o2;
    o2 = t2[2 * n3] ? "required" : t2[2 * n3 + 1] ? "supported" : "unsupported", r2[e3] = o2;
  });
  const n2 = t2.slice(2 * u.length);
  return r2.extra_bits = { start_bit: 2 * u.length, bits: n2, has_required: n2.reduce((e3, t3, r3) => r3 % 2 != 0 ? e3 || false : e3 || t3, false) }, r2;
} };
function g(e2) {
  return (t2) => ({ tagCode: parseInt(e2), words: n.encode("unknown", t2, Number.MAX_SAFE_INTEGER) });
}
function b(e2) {
  return e2.reverse().reduce((e3, t2, r2) => e3 + t2 * Math.pow(32, r2), 0);
}
var v = (e2) => Uint8Array.from(e2.match(/.{1,2}/g).map((e3) => parseInt(e3, 16)));
var E = (e2) => {
  if (!e2) return null;
  try {
    const t2 = (function(e3, t3) {
      if ("string" != typeof e3) throw new Error("Lightning Payment Request must be string");
      if ("ln" !== e3.slice(0, 2).toLowerCase()) throw new Error("Not a proper lightning payment request");
      const r3 = [], s3 = n.decode(e3, Number.MAX_SAFE_INTEGER);
      e3 = e3.toLowerCase();
      const u3 = s3.prefix;
      let v5 = s3.words, E4 = e3.slice(u3.length + 1), x4 = v5.slice(-104);
      v5 = v5.slice(0, -104);
      let A4 = u3.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);
      if (A4 && !A4[2] && (A4 = u3.match(/^ln(\S+)$/)), !A4) throw new Error("Not a proper lightning payment request");
      r3.push({ name: "lightning_network", letters: "ln" });
      const k4 = A4[1];
      let $4;
      switch (k4) {
        case i2.bech32:
          $4 = i2;
          break;
        case a.bech32:
          $4 = a;
          break;
        case c.bech32:
          $4 = c;
          break;
        case h.bech32:
          $4 = h;
          break;
        case l.bech32:
          $4 = l;
      }
      if (!$4 || $4.bech32 !== k4) throw new Error("Unknown coin bech32 prefix");
      r3.push({ name: "coin_network", letters: k4, value: $4 });
      const _3 = A4[2];
      let U3;
      _3 ? (U3 = (function(e4, t4) {
        let r4, n2;
        if (e4.slice(-1).match(/^[munp]$/)) r4 = e4.slice(-1), n2 = e4.slice(0, -1);
        else {
          if (e4.slice(-1).match(/^[^munp0-9]$/)) throw new Error("Not a valid multiplier for the amount");
          n2 = e4;
        }
        if (!n2.match(/^\d+$/)) throw new Error("Not a valid human readable amount");
        const o2 = BigInt(n2), s4 = r4 ? o2 * p / f[r4] : o2 * p;
        if ("p" === r4 && o2 % BigInt(10) !== BigInt(0) || s4 > d) throw new Error("Amount is outside of valid range");
        return s4.toString();
      })(_3 + A4[3]), r3.push({ name: "amount", letters: A4[2] + A4[3], value: U3 })) : U3 = null, r3.push({ name: "separator", letters: "1" });
      const L3 = b(v5.slice(0, 7));
      let D3, N3, I3, S3;
      for (v5 = v5.slice(7), r3.push({ name: "timestamp", letters: E4.slice(0, 7), value: L3 }), E4 = E4.slice(7); v5.length > 0; ) {
        const e4 = v5[0].toString();
        D3 = y[e4] || "unknown_tag", N3 = m[e4] || g(e4), v5 = v5.slice(1), I3 = b(v5.slice(0, 2)), v5 = v5.slice(2), S3 = v5.slice(0, I3), v5 = v5.slice(I3), r3.push({ name: D3, tag: E4[0], letters: E4.slice(0, 3 + I3), value: N3(S3) }), E4 = E4.slice(3 + I3);
      }
      r3.push({ name: "signature", letters: E4.slice(0, 104), value: o.encode(n.fromWordsUnsafe(x4)) }), E4 = E4.slice(104), r3.push({ name: "checksum", letters: E4 });
      let R3 = { paymentRequest: e3, sections: r3, get expiry() {
        let e4 = r3.find((e5) => "expiry" === e5.name);
        if (e4) return P3("timestamp") + e4.value;
      }, get route_hints() {
        return r3.filter((e4) => "route_hint" === e4.name).map((e4) => e4.value);
      } };
      for (let e4 in w) "route_hint" !== e4 && Object.defineProperty(R3, e4, { get: () => P3(e4) });
      return R3;
      function P3(e4) {
        let t4 = r3.find((t5) => t5.name === e4);
        return t4 ? t4.value : void 0;
      }
    })(e2);
    if (!t2 || !t2.sections) return null;
    const r2 = t2.sections.find((e3) => "payment_hash" === e3.name);
    if ("payment_hash" !== (null == r2 ? void 0 : r2.name) || !r2.value) return null;
    const s2 = r2.value;
    let u2 = 0;
    const v4 = t2.sections.find((e3) => "amount" === e3.name);
    "amount" === (null == v4 ? void 0 : v4.name) && v4.value && (u2 = parseInt(v4.value) / 1e3);
    const E3 = t2.sections.find((e3) => "timestamp" === e3.name);
    if ("timestamp" !== (null == E3 ? void 0 : E3.name) || !E3.value) return null;
    const x3 = E3.value;
    let A3;
    const k3 = t2.sections.find((e3) => "expiry" === e3.name);
    "expiry" === (null == k3 ? void 0 : k3.name) && (A3 = k3.value);
    const $3 = t2.sections.find((e3) => "description" === e3.name);
    return { paymentHash: s2, satoshi: u2, timestamp: x3, expiry: A3, description: "description" === (null == $3 ? void 0 : $3.name) ? null == $3 ? void 0 : $3.value : void 0 };
  } catch (e3) {
    return null;
  }
};
function x(e2, t2 = true) {
  if (e2.destroyed) throw new Error("Hash instance has been destroyed");
  if (t2 && e2.finished) throw new Error("Hash#digest() has already been called");
}
var A = (e2) => e2 instanceof Uint8Array;
var k = (e2) => new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
var $ = (e2, t2) => e2 << 32 - t2 | e2 >>> t2;
if (68 !== new Uint8Array(new Uint32Array([287454020]).buffer)[0]) throw new Error("Non little-endian hardware is not supported");
var _ = Array.from({ length: 256 }, (e2, t2) => t2.toString(16).padStart(2, "0"));
function U(e2) {
  if (!A(e2)) throw new Error("Uint8Array expected");
  let t2 = "";
  for (let r2 = 0; r2 < e2.length; r2++) t2 += _[e2[r2]];
  return t2;
}
function L(e2) {
  if ("string" == typeof e2 && (e2 = (function(e3) {
    if ("string" != typeof e3) throw new Error("utf8ToBytes expected string, got " + typeof e3);
    return new Uint8Array(new TextEncoder().encode(e3));
  })(e2)), !A(e2)) throw new Error("expected Uint8Array, got " + typeof e2);
  return e2;
}
var D = class {
  clone() {
    return this._cloneInto();
  }
};
function N(e2) {
  const t2 = (t3) => e2().update(L(t3)).digest(), r2 = e2();
  return t2.outputLen = r2.outputLen, t2.blockLen = r2.blockLen, t2.create = () => e2(), t2;
}
var I = class extends D {
  constructor(e2, t2, r2, n2) {
    super(), this.blockLen = e2, this.outputLen = t2, this.padOffset = r2, this.isLE = n2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e2), this.view = k(this.buffer);
  }
  update(e2) {
    x(this);
    const { view: t2, buffer: r2, blockLen: n2 } = this, o2 = (e2 = L(e2)).length;
    for (let s2 = 0; s2 < o2; ) {
      const i3 = Math.min(n2 - this.pos, o2 - s2);
      if (i3 !== n2) r2.set(e2.subarray(s2, s2 + i3), this.pos), this.pos += i3, s2 += i3, this.pos === n2 && (this.process(t2, 0), this.pos = 0);
      else {
        const t3 = k(e2);
        for (; n2 <= o2 - s2; s2 += n2) this.process(t3, s2);
      }
    }
    return this.length += e2.length, this.roundClean(), this;
  }
  digestInto(e2) {
    x(this), (function(e3, t3) {
      !(function(e4, ...t4) {
        if (!(e4 instanceof Uint8Array)) throw new Error("Expected Uint8Array");
        if (t4.length > 0 && !t4.includes(e4.length)) throw new Error(`Expected Uint8Array of length ${t4}, not of length=${e4.length}`);
      })(e3);
      const r3 = t3.outputLen;
      if (e3.length < r3) throw new Error(`digestInto() expects output buffer of length at least ${r3}`);
    })(e2, this), this.finished = true;
    const { buffer: t2, view: r2, blockLen: n2, isLE: o2 } = this;
    let { pos: s2 } = this;
    t2[s2++] = 128, this.buffer.subarray(s2).fill(0), this.padOffset > n2 - s2 && (this.process(r2, 0), s2 = 0);
    for (let e3 = s2; e3 < n2; e3++) t2[e3] = 0;
    !(function(e3, t3, r3, n3) {
      if ("function" == typeof e3.setBigUint64) return e3.setBigUint64(t3, r3, n3);
      const o3 = BigInt(32), s3 = BigInt(4294967295), i4 = Number(r3 >> o3 & s3), a3 = Number(r3 & s3), c3 = n3 ? 0 : 4;
      e3.setUint32(t3 + (n3 ? 4 : 0), i4, n3), e3.setUint32(t3 + c3, a3, n3);
    })(r2, n2 - 8, BigInt(8 * this.length), o2), this.process(r2, 0);
    const i3 = k(e2), a2 = this.outputLen;
    if (a2 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c2 = a2 / 4, h3 = this.get();
    if (c2 > h3.length) throw new Error("_sha2: outputLen bigger than state");
    for (let e3 = 0; e3 < c2; e3++) i3.setUint32(4 * e3, h3[e3], o2);
  }
  digest() {
    const { buffer: e2, outputLen: t2 } = this;
    this.digestInto(e2);
    const r2 = e2.slice(0, t2);
    return this.destroy(), r2;
  }
  _cloneInto(e2) {
    e2 || (e2 = new this.constructor()), e2.set(...this.get());
    const { blockLen: t2, buffer: r2, length: n2, finished: o2, destroyed: s2, pos: i3 } = this;
    return e2.length = n2, e2.pos = i3, e2.finished = o2, e2.destroyed = s2, n2 % t2 && e2.buffer.set(r2), e2;
  }
};
var S = (e2, t2, r2) => e2 & t2 ^ e2 & r2 ^ t2 & r2;
var R = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var P = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var T = new Uint32Array(64);
var W = class extends I {
  constructor() {
    super(64, 32, 8, false), this.A = 0 | P[0], this.B = 0 | P[1], this.C = 0 | P[2], this.D = 0 | P[3], this.E = 0 | P[4], this.F = 0 | P[5], this.G = 0 | P[6], this.H = 0 | P[7];
  }
  get() {
    const { A: e2, B: t2, C: r2, D: n2, E: o2, F: s2, G: i3, H: a2 } = this;
    return [e2, t2, r2, n2, o2, s2, i3, a2];
  }
  set(e2, t2, r2, n2, o2, s2, i3, a2) {
    this.A = 0 | e2, this.B = 0 | t2, this.C = 0 | r2, this.D = 0 | n2, this.E = 0 | o2, this.F = 0 | s2, this.G = 0 | i3, this.H = 0 | a2;
  }
  process(e2, t2) {
    for (let r3 = 0; r3 < 16; r3++, t2 += 4) T[r3] = e2.getUint32(t2, false);
    for (let e3 = 16; e3 < 64; e3++) {
      const t3 = T[e3 - 15], r3 = T[e3 - 2], n3 = $(t3, 7) ^ $(t3, 18) ^ t3 >>> 3, o3 = $(r3, 17) ^ $(r3, 19) ^ r3 >>> 10;
      T[e3] = o3 + T[e3 - 7] + n3 + T[e3 - 16] | 0;
    }
    let { A: r2, B: n2, C: o2, D: s2, E: i3, F: a2, G: c2, H: h3 } = this;
    for (let e3 = 0; e3 < 64; e3++) {
      const t3 = h3 + ($(i3, 6) ^ $(i3, 11) ^ $(i3, 25)) + ((l2 = i3) & a2 ^ ~l2 & c2) + R[e3] + T[e3] | 0, u2 = ($(r2, 2) ^ $(r2, 13) ^ $(r2, 22)) + S(r2, n2, o2) | 0;
      h3 = c2, c2 = a2, a2 = i3, i3 = s2 + t3 | 0, s2 = o2, o2 = n2, n2 = r2, r2 = t3 + u2 | 0;
    }
    var l2;
    r2 = r2 + this.A | 0, n2 = n2 + this.B | 0, o2 = o2 + this.C | 0, s2 = s2 + this.D | 0, i3 = i3 + this.E | 0, a2 = a2 + this.F | 0, c2 = c2 + this.G | 0, h3 = h3 + this.H | 0, this.set(r2, n2, o2, s2, i3, a2, c2, h3);
  }
  roundClean() {
    T.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var B = N(() => new W());
var j = class {
  constructor(e2) {
    var t2, r2, n2, o2;
    if (this.paymentRequest = void 0, this.paymentHash = void 0, this.preimage = void 0, this.verify = void 0, this.satoshi = void 0, this.expiry = void 0, this.timestamp = void 0, this.createdDate = void 0, this.expiryDate = void 0, this.description = void 0, this.successAction = void 0, this.paymentRequest = e2.pr, !this.paymentRequest) throw new Error("Invalid payment request");
    const s2 = E(this.paymentRequest);
    if (!s2) throw new Error("Failed to decode payment request");
    this.paymentHash = s2.paymentHash, this.satoshi = s2.satoshi, this.timestamp = s2.timestamp, this.expiry = s2.expiry, this.createdDate = new Date(1e3 * this.timestamp), this.expiryDate = this.expiry ? new Date(1e3 * (this.timestamp + this.expiry)) : void 0, this.description = null != (t2 = s2.description) ? t2 : null, this.verify = null != (r2 = e2.verify) ? r2 : null, this.preimage = null != (n2 = e2.preimage) ? n2 : null, this.successAction = null != (o2 = e2.successAction) ? o2 : null;
  }
  async isPaid() {
    if (this.preimage) return this.validatePreimage(this.preimage);
    if (this.verify) return await this.verifyPayment();
    throw new Error("Could not verify payment");
  }
  validatePreimage(e2) {
    if (!e2 || !this.paymentHash) return false;
    try {
      const t2 = U(B(v(e2)));
      return this.paymentHash === t2;
    } catch (e3) {
      return false;
    }
  }
  async verifyPayment() {
    try {
      if (!this.verify) throw new Error("LNURL verify not available");
      const e2 = await fetch(this.verify);
      if (!e2.ok) throw new Error(`Verification request failed: ${e2.status} ${e2.statusText}`);
      const t2 = await e2.json();
      return t2.preimage && (this.preimage = t2.preimage), t2.settled;
    } catch (e2) {
      return console.error("Failed to check LNURL-verify", e2), false;
    }
  }
  hasExpired() {
    const { expiryDate: e2 } = this;
    return !!e2 && e2.getTime() < Date.now();
  }
};
var H = (e2) => {
  if ("keysend" !== e2.tag) throw new Error("Invalid keysend params");
  if ("OK" !== e2.status) throw new Error("Keysend status not OK");
  if (!e2.pubkey) throw new Error("Pubkey does not exist");
  let t2, r2;
  return e2.customData && e2.customData[0] && (t2 = e2.customData[0].customKey, r2 = e2.customData[0].customValue), { destination: e2.pubkey, customKey: t2, customValue: r2 };
};
async function O({ satoshi: e2, comment: t2, p: r2, e: n2, relays: o2 }, s2 = {}) {
  const i3 = s2.nostr || globalThis.nostr;
  if (!i3) throw new Error("nostr option or window.nostr is not available");
  const a2 = [["relays", ...o2], ["amount", e2.toString()]];
  r2 && a2.push(["p", r2]), n2 && a2.push(["e", n2]);
  const c2 = { pubkey: await i3.getPublicKey(), created_at: Math.floor(Date.now() / 1e3), kind: 9734, tags: a2, content: null != t2 ? t2 : "" };
  return c2.id = F(c2), await i3.signEvent(c2);
}
function C(e2) {
  if ("string" != typeof e2.content) return false;
  if ("number" != typeof e2.created_at) return false;
  if (!Array.isArray(e2.tags)) return false;
  for (let t2 = 0; t2 < e2.tags.length; t2++) {
    const r2 = e2.tags[t2];
    if (!Array.isArray(r2)) return false;
    for (let e3 = 0; e3 < r2.length; e3++) if ("object" == typeof r2[e3]) return false;
  }
  return true;
}
function K(e2) {
  if (!C(e2)) throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, e2.pubkey, e2.created_at, e2.kind, e2.tags, e2.content]);
}
function F(e2) {
  return U(B(K(e2)));
}
function V(e2, t2) {
  let r2, n2;
  var o2, s2;
  return t2 && e2 && (r2 = null == (o2 = e2.names) ? void 0 : o2[t2], n2 = r2 ? null == (s2 = e2.relays) ? void 0 : s2[r2] : void 0), [e2, r2, n2];
}
var q = /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=+$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=+$,\w]+@)[A-Za-z0-9.-]+)((?:\/[+~%/.\w-_]*)?\??(?:[-+=&;%@.\w_]*)#?(?:[\w]*))?)/;
var z = (e2) => !!e2 && q.test(e2);
var M = ({ amount: e2, min: t2, max: r2 }) => e2 > 0 && e2 >= t2 && e2 <= r2;
var G = async (e2) => {
  if ("payRequest" !== e2.tag) throw new Error("Invalid pay service params");
  const t2 = (e2.callback + "").trim();
  if (!z(t2)) throw new Error("Callback must be a valid url");
  const r2 = Math.ceil(Number(e2.minSendable || 0)), n2 = Math.floor(Number(e2.maxSendable));
  if (!r2 || !n2 || r2 > n2) throw new Error("Invalid pay service params");
  let o2, s2;
  try {
    o2 = JSON.parse(e2.metadata + ""), s2 = U(B(e2.metadata + ""));
  } catch (e3) {
    o2 = [], s2 = U(B("[]"));
  }
  let i3 = "", a2 = "", c2 = "", h3 = "";
  for (let e3 = 0; e3 < o2.length; e3++) {
    const [t3, r3] = o2[e3];
    switch (t3) {
      case "text/plain":
        c2 = r3;
        break;
      case "text/identifier":
        h3 = r3;
        break;
      case "text/email":
        i3 = r3;
        break;
      case "image/png;base64":
      case "image/jpeg;base64":
        a2 = "data:" + t3 + "," + r3;
    }
  }
  const l2 = e2.payerData;
  let u2;
  try {
    u2 = new URL(t2).hostname;
  } catch (e3) {
  }
  return { callback: t2, fixed: r2 === n2, min: r2, max: n2, domain: u2, metadata: o2, metadataHash: s2, identifier: h3, email: i3, description: c2, image: a2, payerData: l2, commentAllowed: Number(e2.commentAllowed) || 0, rawData: e2, allowsNostr: e2.allowsNostr || false };
};
function J() {
  return J = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2];
      for (var n2 in r2) Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
    }
    return e2;
  }, J.apply(this, arguments);
}
var Z = async (e2, t2) => {
  const { boost: r2 } = e2;
  t2 || (t2 = {});
  const n2 = t2.webln || globalThis.webln;
  if (!n2) throw new Error("WebLN not available");
  if (!n2.keysend) throw new Error("Keysend not available in current WebLN provider");
  const o2 = e2.amount || Math.floor(r2.value_msat / 1e3), s2 = { destination: e2.destination, amount: o2, customRecords: { 7629169: JSON.stringify(r2) } };
  return e2.customKey && e2.customValue && (s2.customRecords[e2.customKey] = e2.customValue), await n2.enable(), await n2.keysend(s2);
};
var X = /^((?:[^<>()[\]\\.,;:\s@"]+(?:\.[^<>()[\]\\.,;:\s@"]+)*)|(?:".+"))@((?:\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(?:(?:[a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var Y = class {
  constructor(e2, t2) {
    this.address = void 0, this.options = void 0, this.username = void 0, this.domain = void 0, this.pubkey = void 0, this.lnurlpData = void 0, this.keysendData = void 0, this.nostrData = void 0, this.nostrPubkey = void 0, this.nostrRelays = void 0, this.webln = void 0, this.address = e2, this.options = { proxy: "https://api.getalby.com/lnurl" }, this.options = Object.assign(this.options, t2), this.parse(), this.webln = this.options.webln;
  }
  parse() {
    const e2 = X.exec(this.address.toLowerCase());
    e2 && (this.username = e2[1], this.domain = e2[2]);
  }
  getWebLN() {
    return this.webln || globalThis.webln;
  }
  async fetch() {
    return this.options.proxy ? this.fetchWithProxy() : this.fetchWithoutProxy();
  }
  async fetchWithProxy() {
    const e2 = await fetch(`${this.options.proxy}/lightning-address-details?${new URLSearchParams({ ln: this.address }).toString()}`);
    if (!e2.ok) throw new Error(`Failed to fetch lnurl info: ${e2.status} ${e2.statusText}`);
    const t2 = await e2.json();
    await this.parseLnUrlPayResponse(t2.lnurlp), this.parseKeysendResponse(t2.keysend), this.parseNostrResponse(t2.nostr);
  }
  async fetchWithoutProxy() {
    this.domain && this.username && await Promise.all([this.fetchLnurlData(), this.fetchKeysendData(), this.fetchNostrData()]);
  }
  async fetchLnurlData() {
    const e2 = await fetch(this.lnurlpUrl());
    if (e2.ok) {
      const t2 = await e2.json();
      await this.parseLnUrlPayResponse(t2);
    }
  }
  async fetchKeysendData() {
    const e2 = await fetch(this.keysendUrl());
    if (e2.ok) {
      const t2 = await e2.json();
      this.parseKeysendResponse(t2);
    }
  }
  async fetchNostrData() {
    const e2 = await fetch(this.nostrUrl());
    if (e2.ok) {
      const t2 = await e2.json();
      this.parseNostrResponse(t2);
    }
  }
  lnurlpUrl() {
    return `https://${this.domain}/.well-known/lnurlp/${this.username}`;
  }
  keysendUrl() {
    return `https://${this.domain}/.well-known/keysend/${this.username}`;
  }
  nostrUrl() {
    return `https://${this.domain}/.well-known/nostr.json?name=${this.username}`;
  }
  async generateInvoice(e2) {
    let t2;
    if (this.options.proxy) {
      const r3 = await fetch(`${this.options.proxy}/generate-invoice?${new URLSearchParams(J({ ln: this.address }, e2)).toString()}`);
      if (!r3.ok) throw new Error(`Failed to generate invoice: ${r3.status} ${r3.statusText}`);
      t2 = (await r3.json()).invoice;
    } else {
      if (!this.lnurlpData) throw new Error("No lnurlpData available. Please call fetch() first.");
      if (!this.lnurlpData.callback || !z(this.lnurlpData.callback)) throw new Error("Valid callback does not exist in lnurlpData");
      const r3 = new URL(this.lnurlpData.callback);
      r3.search = new URLSearchParams(e2).toString();
      const n3 = await fetch(r3.toString());
      if (!n3.ok) throw new Error(`Failed to generate invoice: ${n3.status} ${n3.statusText}`);
      t2 = await n3.json();
    }
    const r2 = t2 && t2.pr && t2.pr.toString();
    if (!r2) throw new Error("Invalid pay service invoice");
    const n2 = { pr: r2 };
    if (t2 && t2.verify && (n2.verify = t2.verify.toString()), t2 && t2.successAction && "object" == typeof t2.successAction) {
      const { tag: e3, message: r3, description: o2, url: s2 } = t2.successAction;
      "message" === e3 ? n2.successAction = { tag: e3, message: r3 } : "url" === e3 && (n2.successAction = { tag: e3, description: o2, url: s2 });
    }
    return new j(n2);
  }
  async requestInvoice(e2) {
    if (!this.lnurlpData) throw new Error("No lnurlpData available. Please call fetch() first.");
    const t2 = 1e3 * e2.satoshi, { commentAllowed: r2, min: n2, max: o2 } = this.lnurlpData;
    if (!M({ amount: t2, min: n2, max: o2 })) throw new Error("Invalid amount");
    if (e2.comment && r2 && r2 > 0 && e2.comment.length > r2) throw new Error(`The comment length must be ${r2} characters or fewer`);
    const s2 = { amount: t2.toString() };
    return e2.comment && (s2.comment = e2.comment), e2.payerdata && (s2.payerdata = JSON.stringify(e2.payerdata)), this.generateInvoice(s2);
  }
  async boost(e2, t2 = 0) {
    if (!this.keysendData) throw new Error("No keysendData available. Please call fetch() first.");
    const { destination: r2, customKey: n2, customValue: o2 } = this.keysendData, s2 = this.getWebLN();
    if (!s2) throw new Error("WebLN not available");
    return Z({ destination: r2, customKey: n2, customValue: o2, amount: t2, boost: e2 }, { webln: s2 });
  }
  async zapInvoice({ satoshi: e2, comment: t2, relays: r2, e: n2 }, o2 = {}) {
    if (!this.lnurlpData) throw new Error("No lnurlpData available. Please call fetch() first.");
    if (!this.nostrPubkey) throw new Error("Nostr Pubkey is missing");
    const s2 = this.nostrPubkey, i3 = 1e3 * e2, { allowsNostr: a2, min: c2, max: h3 } = this.lnurlpData;
    if (!M({ amount: i3, min: c2, max: h3 })) throw new Error("Invalid amount");
    if (!a2) throw new Error("Your provider does not support zaps");
    const l2 = await O({ satoshi: i3, comment: t2, p: s2, e: n2, relays: r2 }, o2), u2 = { amount: i3.toString(), nostr: JSON.stringify(l2) };
    return await this.generateInvoice(u2);
  }
  async zap(e2, t2 = {}) {
    const r2 = this.zapInvoice(e2, t2), n2 = this.getWebLN();
    if (!n2) throw new Error("WebLN not available");
    return await n2.enable(), n2.sendPayment((await r2).paymentRequest);
  }
  async parseLnUrlPayResponse(e2) {
    e2 && (this.lnurlpData = await G(e2));
  }
  parseKeysendResponse(e2) {
    e2 && (this.keysendData = H(e2));
  }
  parseNostrResponse(e2) {
    e2 && ([this.nostrData, this.nostrPubkey, this.nostrRelays] = V(e2, this.username));
  }
};
var ee = class {
  constructor(e2) {
    this.storage = void 0, this.storage = e2 || {};
  }
  getItem(e2) {
    return this.storage[e2];
  }
  setItem(e2, t2) {
    this.storage[e2] = t2;
  }
};
var ne = new ee();
var ie = async (e2) => {
  const t2 = "https://getalby.com/api/rates/" + e2.toLowerCase() + ".json", r2 = await fetch(t2);
  if (!r2.ok) throw new Error(`Failed to fetch rate: ${r2.status} ${r2.statusText}`);
  return (await r2.json()).rate_float / 1e8;
};
var ae = async ({ satoshi: e2, currency: t2 }) => {
  const r2 = await ie(t2);
  return Number(e2) * r2;
};
var ce = async ({ amount: e2, currency: t2 }) => {
  const r2 = await ie(t2);
  return Math.floor(Number(e2) / r2);
};
var he = async ({ satoshi: e2, currency: t2, locale: r2 }) => (r2 || (r2 = "en"), (await ae({ satoshi: e2, currency: t2 })).toLocaleString(r2, { style: "currency", currency: t2 }));
var le = { __proto__: null, getFiatBtcRate: ie, getFiatValue: ae, getSatoshiValue: ce, getFormattedFiatValue: he };

// node_modules/.pnpm/@getalby+sdk@5.1.2_typescript@5.9.2/node_modules/@getalby/sdk/dist/index.modern.js
function h2() {
  return h2 = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var i3 in n2) Object.prototype.hasOwnProperty.call(n2, i3) && (e2[i3] = n2[i3]);
    }
    return e2;
  }, h2.apply(this, arguments);
}
function d2(e2, t2) {
  if (null == e2) return {};
  var n2, i3, s2 = {}, o2 = Object.keys(e2);
  for (i3 = 0; i3 < o2.length; i3++) t2.indexOf(n2 = o2[i3]) >= 0 || (s2[n2] = e2[n2]);
  return s2;
}
var p2 = class {
  constructor() {
    this.events = {};
  }
  on(e2, t2) {
    this.events[e2] || (this.events[e2] = []), this.events[e2].push(t2);
  }
  off(e2, t2) {
    this.events[e2] && (this.events[e2] = this.events[e2].filter((e3) => e3 !== t2));
  }
  emit(e2, t2) {
    this.events[e2] && this.events[e2].forEach((e3) => e3(t2));
  }
};
function y2(e2) {
  return Object.entries(e2).map(([e3, t2]) => e3 && t2 ? `${e3}=${t2}` : "").filter((e3) => e3).join("&");
}
function w2(e2, t2) {
  return `Basic ${btoa(`${e2}:${t2}`)}`;
}
var m2 = { __proto__: null, buildQueryString: y2, basicAuthHeader: w2 };
var f2 = class extends Error {
  constructor(e2, t2, n2, i3) {
    let s2 = e2.toString();
    t2 && (s2 += ` ${t2}`), s2 += ": ", s2 += i3.message ? i3.message : JSON.stringify(i3), super(s2), this.status = void 0, this.statusText = void 0, this.headers = void 0, this.error = void 0, this.status = e2, this.statusText = t2, this.headers = n2, this.error = i3;
  }
};
var g2 = { __proto__: null, OAuthClient: class {
}, AuthClient: class {
}, AlbyResponseError: f2 };
var v3 = ["auth", "endpoint", "params", "request_body", "method", "max_retries", "base_url", "user_agent", "headers"];
var _2 = "https://api.getalby.com";
async function b2(e2, t2, n2 = 0) {
  const i3 = await fetch(e2, t2);
  if (429 === i3.status && n2 > 0) {
    const s2 = Number(i3.headers.get("x-rate-limit-reset")), o2 = Number(i3.headers.get("x-rate-limit-remaining")), r2 = 1e3 * s2 - Date.now();
    let a2 = 1e3;
    return 0 === o2 && (a2 = r2), await new Promise((e3) => setTimeout(e3, a2)), b2(e2, t2, n2 - 1);
  }
  return i3;
}
async function k2(e2) {
  let { auth: t2, endpoint: n2, params: i3 = {}, request_body: s2, method: o2, max_retries: r2, base_url: a2 = _2, user_agent: c2, headers: l2 } = e2, u2 = d2(e2, v3);
  const p3 = new URL(a2 + n2);
  p3.search = y2(i3);
  const w3 = "POST" === o2 && !!s2, m3 = t2 ? await t2.getAuthHeader(p3.href, o2) : void 0, g3 = await b2(p3.toString(), h2({ headers: h2({}, w3 ? { "Content-Type": "application/json; charset=utf-8" } : void 0, m3, l2, { "User-Agent": null != c2 ? c2 : "@getalby/sdk", "X-User-Agent": null != c2 ? c2 : "@getalby/sdk" }), method: o2, body: w3 ? JSON.stringify(s2) : void 0 }, u2), r2);
  if (!g3.ok) {
    const e3 = await g3.json();
    throw new f2(g3.status, g3.statusText, g3.headers, e3);
  }
  return g3;
}
async function E2(e2) {
  return (await k2(e2)).json();
}
var P2 = (e2) => e2.reduce((e3, t2) => e3 + t2.toString(16).padStart(2, "0"), "");
var T2 = ["expires_in"];
var N2 = ["token"];
function q2(e2) {
  const { expires_in: t2 } = e2;
  return h2({}, d2(e2, T2), !!t2 && { expires_at: Date.now() + 1e3 * t2 });
}
var x2 = class {
  constructor(e2) {
    this.bearer_token = void 0, this.bearer_token = e2;
  }
  getAuthHeader() {
    return { Authorization: `Bearer ${this.bearer_token}` };
  }
};
var R2 = { __proto__: null, OAuth2User: class {
  constructor(e2) {
    this.token = void 0, this.options = void 0, this.code_verifier = void 0, this.code_challenge = void 0, this._refreshAccessTokenPromise = void 0, this._tokenEvents = void 0, this._tokenEvents = new p2();
    const { token: t2 } = e2, n2 = d2(e2, N2);
    this.options = h2({ client_secret: "" }, n2), this.token = t2, this._refreshAccessTokenPromise = null;
  }
  on(e2, t2) {
    this._tokenEvents.on(e2, t2);
  }
  async refreshAccessToken() {
    var e2 = this;
    return this._refreshAccessTokenPromise || (this._refreshAccessTokenPromise = new Promise(async function(t2, n2) {
      try {
        var i3;
        const n3 = null == (i3 = e2.token) ? void 0 : i3.refresh_token, { client_id: s2, client_secret: o2, request_options: r2, user_agent: a2 } = e2.options;
        if (!s2) throw new Error("client_id is required");
        if (!n3) throw new Error("refresh_token is required");
        const c2 = q2(await E2(h2({}, r2, { endpoint: "/oauth/token", params: { client_id: s2, grant_type: "refresh_token", refresh_token: n3 }, user_agent: a2, method: "POST", headers: h2({}, null == r2 ? void 0 : r2.headers, { "Content-type": "application/x-www-form-urlencoded" }, { Authorization: w2(s2, o2) }) })));
        e2.token = c2, t2({ token: c2 }), e2._tokenEvents.emit("tokenRefreshed", e2.token);
      } catch (t3) {
        console.error(t3), n2(t3), e2._tokenEvents.emit("tokenRefreshFailed", t3);
      } finally {
        e2._refreshAccessTokenPromise = null;
      }
    })), this._refreshAccessTokenPromise;
  }
  isAccessTokenExpired() {
    var e2, t2;
    const n2 = null == (e2 = this.token) ? void 0 : e2.refresh_token, i3 = null == (t2 = this.token) ? void 0 : t2.expires_at;
    return !i3 || !!n2 && i3 <= Date.now() + 1e3;
  }
  async requestAccessToken(e2) {
    const { client_id: t2, client_secret: n2, callback: i3, request_options: s2, user_agent: o2 } = this.options, r2 = this.code_verifier;
    if (!t2) throw new Error("client_id is required");
    if (!n2 && !r2) throw new Error("either client_secret is required, or code should be generated using a challenge");
    if (!i3) throw new Error("callback is required");
    const a2 = { code: e2, grant_type: "authorization_code", code_verifier: r2, client_id: t2, redirect_uri: i3 }, c2 = q2(await E2(h2({}, s2, { endpoint: "/oauth/token", params: a2, user_agent: o2, method: "POST", headers: h2({}, null == s2 ? void 0 : s2.headers, { "Content-Type": "application/x-www-form-urlencoded" }, { Authorization: w2(t2, n2) }) })));
    return this.token = c2, { token: c2 };
  }
  async generateAuthURL(e2) {
    e2 || (e2 = {});
    const { client_id: t2, callback: n2, scopes: i3 } = this.options;
    if (!n2) throw new Error("callback required");
    if (!i3) throw new Error("scopes required");
    let s2;
    "S256" === e2.code_challenge_method ? (await this._generateS256Challenge(), s2 = "S256") : "plain" === e2.code_challenge_method && e2.code_challenge && (this.code_challenge = e2.code_challenge, this.code_verifier = e2.code_challenge, s2 = "plain");
    const o2 = this.code_challenge, r2 = new URL(e2.authorizeUrl || "https://getalby.com/oauth");
    return r2.search = y2(h2({}, e2, { client_id: t2, scope: i3.join(" "), response_type: "code", redirect_uri: n2, code_challenge_method: s2, code_challenge: o2 })), r2.toString();
  }
  async getAuthHeader() {
    var e2;
    if (null == (e2 = this.token) || !e2.access_token) throw new Error("access_token is required");
    return this.isAccessTokenExpired() && await this.refreshAccessToken(), { Authorization: `Bearer ${this.token.access_token}` };
  }
  async _generateS256Challenge() {
    const e2 = crypto.getRandomValues(new Uint8Array(64));
    this.code_verifier = P2(e2);
    const t2 = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(this.code_verifier)), n2 = new Uint8Array(t2);
    this.code_challenge = btoa(String.fromCharCode(...n2)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
}, OAuth2Bearer: x2 };
function S2(e2) {
  const t2 = {};
  return e2.recipient.customKey && e2.recipient.customValue && (t2[e2.recipient.customKey] = e2.recipient.customValue), t2[7629169] = JSON.stringify(e2.boostagram), { destination: e2.recipient.address, amount: e2.amount, custom_records: t2 };
}
var I2 = class {
  constructor(e2, t2) {
    this.auth = void 0, this.defaultRequestOptions = void 0, this.auth = "string" == typeof e2 ? new x2(e2) : e2, this.defaultRequestOptions = h2({}, t2, { user_agent: null == t2 ? void 0 : t2.user_agent });
  }
  accountBalance(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/balance", params: e2, method: "GET" }));
  }
  signMessage(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/signatures", request_body: e2, method: "POST" }));
  }
  accountSummary(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/user/summary", params: e2, method: "GET" }));
  }
  accountInformation(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/user/me", params: e2, method: "GET" }));
  }
  accountValue4Value(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/user/value4value", params: e2, method: "GET" }));
  }
  incomingInvoices(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/invoices/incoming", params: e2, method: "GET" }));
  }
  outgoingInvoices(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/invoices/outgoing", params: e2, method: "GET" }));
  }
  invoices(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/invoices", params: e2, method: "GET" }));
  }
  getInvoice(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: `/invoices/${e2}`, method: "GET" }));
  }
  decodeInvoice(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: `/decode/bolt11/${e2}`, method: "GET" }));
  }
  createInvoice(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/invoices", request_body: e2, method: "POST" }));
  }
  keysend(e2, t2) {
    let n2, i3;
    return Array.isArray(e2) ? (n2 = "/payments/keysend/multi", i3 = { keysends: e2.map((e3) => h2({}, e3, { custom_records: e3.customRecords })) }) : (n2 = "/payments/keysend", i3 = h2({}, e2, { custom_records: e2.customRecords })), E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: n2, request_body: i3, method: "POST" }));
  }
  sendPayment(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/payments/bolt11", request_body: e2, method: "POST" }));
  }
  sendBoostagram(e2, t2) {
    let n2, i3;
    return Array.isArray(e2) ? (n2 = "/payments/keysend/multi", i3 = { keysends: e2.map((e3) => S2(e3)) }) : (n2 = "/payments/keysend", i3 = S2(e2)), E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: n2, request_body: i3, method: "POST" }));
  }
  sendBoostagramToAlbyAccount(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/payments/keysend", request_body: { destination: "030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3", custom_records: { 696969: e2.account }, amount: e2.amount, memo: e2.memo }, method: "POST" }));
  }
  createWebhookEndpoint(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/webhook_endpoints", request_body: e2, method: "POST" }));
  }
  deleteWebhookEndpoint(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: `/webhook_endpoints/${e2}`, method: "DELETE" }));
  }
  getSwapInfo(e2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, e2, { endpoint: "/swaps/info", method: "GET" }));
  }
  createSwap(e2, t2) {
    return E2(h2({ auth: this.auth }, this.defaultRequestOptions, t2, { endpoint: "/swaps", method: "POST", request_body: e2 }));
  }
};
var A2 = { __proto__: null, auth: R2, types: g2, utils: m2, Client: I2 };
if (68 !== new Uint8Array(new Uint32Array([287454020]).buffer)[0]) throw new Error("Non little-endian hardware is not supported");
var U2 = Array.from({ length: 256 }, (e2, t2) => t2.toString(16).padStart(2, "0"));
function O2(e2) {
  if (!(e2 instanceof Uint8Array)) throw new Error("Uint8Array expected");
  let t2 = "";
  for (let n2 = 0; n2 < e2.length; n2++) t2 += U2[e2[n2]];
  return t2;
}
function C2(e2) {
  if ("string" != typeof e2) throw new Error("hex string expected, got " + typeof e2);
  const t2 = e2.length;
  if (t2 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t2);
  const n2 = new Uint8Array(t2 / 2);
  for (let t3 = 0; t3 < n2.length; t3++) {
    const i3 = 2 * t3, s2 = e2.slice(i3, i3 + 2), o2 = Number.parseInt(s2, 16);
    if (Number.isNaN(o2) || o2 < 0) throw new Error("Invalid byte sequence");
    n2[t3] = o2;
  }
  return n2;
}
var M2 = class extends Error {
  constructor(e2, t2) {
    super(e2), this.code = void 0, this.code = t2;
  }
};
var W2 = class extends M2 {
};
var $2 = class extends M2 {
};
var F2 = class extends M2 {
};
var L2 = class extends F2 {
};
var K2 = class extends F2 {
};
var j2 = class extends M2 {
};
var J2 = class extends M2 {
};
var B2 = class extends M2 {
};
var H2 = class extends M2 {
};
var z2 = class extends M2 {
};
var D2 = class _D {
  static parseWalletConnectUrl(e2) {
    e2 = e2.replace("nostrwalletconnect://", "http://").replace("nostr+walletconnect://", "http://").replace("nostrwalletconnect:", "http://").replace("nostr+walletconnect:", "http://");
    const t2 = new URL(e2), n2 = t2.searchParams.get("relay");
    if (!n2) throw new Error("No relay URL found in connection string");
    const i3 = { walletPubkey: t2.host, relayUrl: n2 }, s2 = t2.searchParams.get("secret");
    s2 && (i3.secret = s2);
    const o2 = t2.searchParams.get("lud16");
    return o2 && (i3.lud16 = o2), i3;
  }
  constructor(n2) {
    this.relay = void 0, this.relayUrl = void 0, this.secret = void 0, this.lud16 = void 0, this.walletPubkey = void 0, this.options = void 0, this._encryptionType = void 0, n2 && n2.nostrWalletConnectUrl && (n2 = h2({}, _D.parseWalletConnectUrl(n2.nostrWalletConnectUrl), n2)), this.options = h2({}, n2 || {}), this.relayUrl = this.options.relayUrl, this.relay = new Relay(this.relayUrl), this.options.secret && (this.secret = this.options.secret.toLowerCase().startsWith("nsec") ? nip19_exports.decode(this.options.secret).data : this.options.secret), this.lud16 = this.options.lud16, this.walletPubkey = this.options.walletPubkey.toLowerCase().startsWith("npub") ? nip19_exports.decode(this.options.walletPubkey).data : this.options.walletPubkey, void 0 === globalThis.WebSocket && console.error("WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments");
  }
  get nostrWalletConnectUrl() {
    return this.getNostrWalletConnectUrl();
  }
  getNostrWalletConnectUrl(e2 = true) {
    let t2 = `nostr+walletconnect://${this.walletPubkey}?relay=${this.relayUrl}&pubkey=${this.publicKey}`;
    return e2 && (t2 = `${t2}&secret=${this.secret}`), this.lud16 && (t2 = `${t2}&lud16=${this.lud16}`), t2;
  }
  get connected() {
    return this.relay.connected;
  }
  get publicKey() {
    if (!this.secret) throw new Error("Missing secret key");
    return getPublicKey(C2(this.secret));
  }
  get encryptionType() {
    if (!this._encryptionType) throw new Error("Missing encryption or version");
    return this._encryptionType;
  }
  getPublicKey() {
    return Promise.resolve(this.publicKey);
  }
  signEvent(e2) {
    if (!this.secret) throw new Error("Missing secret key");
    return Promise.resolve(finalizeEvent(e2, C2(this.secret)));
  }
  getEventHash(e2) {
    return getEventHash(e2);
  }
  close() {
    return this.relay.close();
  }
  async encrypt(e2, t2) {
    if (!this.secret) throw new Error("Missing secret");
    let n2;
    if ("nip04" === this.encryptionType) n2 = await nip04_exports.encrypt(this.secret, e2, t2);
    else {
      const i3 = nip44_exports.getConversationKey(C2(this.secret), e2);
      n2 = nip44_exports.encrypt(t2, i3);
    }
    return n2;
  }
  async decrypt(e2, t2) {
    if (!this.secret) throw new Error("Missing secret");
    let n2;
    if ("nip04" === this.encryptionType) n2 = await nip04_exports.decrypt(this.secret, e2, t2);
    else {
      const i3 = nip44_exports.getConversationKey(C2(this.secret), e2);
      n2 = nip44_exports.decrypt(t2, i3);
    }
    return n2;
  }
  static getAuthorizationUrl(e2, t2 = {}, n2) {
    if (e2.indexOf("/#/") > -1) throw new Error("hash router paths not supported");
    const i3 = new URL(e2);
    return t2.name && i3.searchParams.set("name", t2.name), i3.searchParams.set("pubkey", n2), t2.returnTo && i3.searchParams.set("return_to", t2.returnTo), t2.budgetRenewal && i3.searchParams.set("budget_renewal", t2.budgetRenewal), t2.expiresAt && i3.searchParams.set("expires_at", Math.floor(t2.expiresAt.getTime() / 1e3).toString()), t2.maxAmount && i3.searchParams.set("max_amount", t2.maxAmount.toString()), t2.requestMethods && i3.searchParams.set("request_methods", t2.requestMethods.join(" ")), t2.notificationTypes && i3.searchParams.set("notification_types", t2.notificationTypes.join(" ")), t2.isolated && i3.searchParams.set("isolated", "true"), t2.metadata && i3.searchParams.set("metadata", JSON.stringify(t2.metadata)), i3;
  }
  static fromAuthorizationUrl(e2, t2 = {}, i3) {
    i3 = i3 || O2(generateSecretKey()), t2.name || (t2.name = document.location.host);
    const s2 = this.getAuthorizationUrl(e2, t2, getPublicKey(C2(i3))), o2 = window.outerHeight / 2 + window.screenY - 300, r2 = window.outerWidth / 2 + window.screenX - 200;
    return new Promise((e3, t3) => {
      const n2 = window.open(s2.toString(), `${document.title} - Wallet Connect`, `height=600,width=400,top=${o2},left=${r2}`);
      if (!n2) return void t3(new Error("failed to execute window.open"));
      const a2 = (o3) => {
        const r3 = o3.data;
        r3 && "nwc:success" === r3.type && o3.origin === `${s2.protocol}//${s2.host}` && (r3.relayUrl || t3(new Error("no relayUrl in response")), r3.walletPubkey || t3(new Error("no walletPubkey in response")), e3(new _D({ relayUrl: r3.relayUrl, walletPubkey: r3.walletPubkey, secret: i3, lud16: r3.lud16 })), clearInterval(c2), window.removeEventListener("message", a2), n2 && n2.close());
      }, c2 = setInterval(() => {
        n2 && n2.closed && (clearInterval(c2), window.removeEventListener("message", a2), t3(new Error("Popup closed")));
      }, 500);
      window.addEventListener("message", a2);
    });
  }
  async getWalletServiceInfo() {
    var e2;
    await this._checkConnected();
    const t2 = await new Promise((e3, t3) => {
      const n3 = [], i4 = this.relay.subscribe([{ kinds: [13194], limit: 1, authors: [this.walletPubkey] }], { eoseTimeout: 1e4 });
      i4.onevent = (e4) => {
        n3.push(e4);
      }, i4.oneose = () => {
        i4.close(), e3(n3);
      };
    });
    if (!t2.length) throw new Error("no info event (kind 13194) returned from relay");
    const n2 = t2[0].content, i3 = t2[0].tags.find((e3) => "notifications" === e3[0]), s2 = t2[0].tags.find((e3) => "v" === e3[0]), o2 = t2[0].tags.find((e3) => "encryption" === e3[0]);
    let r2 = ["nip04"];
    return s2 && s2[1].includes("1.0") && r2.push("nip44_v2"), o2 && (r2 = o2[1].split(" ")), { encryptions: r2, capabilities: n2.split(/[ |,]/g), notifications: (null == i3 || null == (e2 = i3[1]) ? void 0 : e2.split(" ")) || [] };
  }
  async getInfo() {
    try {
      return await this.executeNip47Request("get_info", {}, (e2) => !!e2.methods, { replyTimeout: 1e4 });
    } catch (e2) {
      throw console.error("Failed to request get_info", e2), e2;
    }
  }
  async getBudget() {
    try {
      return await this.executeNip47Request("get_budget", {}, (e2) => void 0 !== e2, { replyTimeout: 1e4 });
    } catch (e2) {
      throw console.error("Failed to request get_budget", e2), e2;
    }
  }
  async getBalance() {
    try {
      return await this.executeNip47Request("get_balance", {}, (e2) => void 0 !== e2.balance, { replyTimeout: 1e4 });
    } catch (e2) {
      throw console.error("Failed to request get_balance", e2), e2;
    }
  }
  async payInvoice(e2) {
    try {
      return await this.executeNip47Request("pay_invoice", e2, (e3) => !!e3);
    } catch (e3) {
      throw console.error("Failed to request pay_invoice", e3), e3;
    }
  }
  async payKeysend(e2) {
    try {
      return await this.executeNip47Request("pay_keysend", e2, (e3) => !!e3.preimage);
    } catch (e3) {
      throw console.error("Failed to request pay_keysend", e3), e3;
    }
  }
  async signMessage(e2) {
    try {
      return await this.executeNip47Request("sign_message", e2, (t2) => t2.message === e2.message && !!t2.signature);
    } catch (e3) {
      throw console.error("Failed to request sign_message", e3), e3;
    }
  }
  async createConnection(e2) {
    try {
      return await this.executeNip47Request("create_connection", e2, (e3) => !!e3.wallet_pubkey);
    } catch (e3) {
      throw console.error("Failed to request create_connection", e3), e3;
    }
  }
  async multiPayInvoice(e2) {
    try {
      return { invoices: await this.executeMultiNip47Request("multi_pay_invoice", e2, e2.invoices.length, (e3) => !!e3.preimage), errors: [] };
    } catch (e3) {
      throw console.error("Failed to request multi_pay_invoice", e3), e3;
    }
  }
  async multiPayKeysend(e2) {
    try {
      return { keysends: await this.executeMultiNip47Request("multi_pay_keysend", e2, e2.keysends.length, (e3) => !!e3.preimage), errors: [] };
    } catch (e3) {
      throw console.error("Failed to request multi_pay_keysend", e3), e3;
    }
  }
  async makeInvoice(e2) {
    try {
      if (!e2.amount) throw new Error("No amount specified");
      return await this.executeNip47Request("make_invoice", e2, (e3) => !!e3.invoice);
    } catch (e3) {
      throw console.error("Failed to request make_invoice", e3), e3;
    }
  }
  async makeHoldInvoice(e2) {
    try {
      if (!e2.amount) throw new Error("No amount specified");
      if (!e2.payment_hash) throw new Error("No payment hash specified");
      return await this.executeNip47Request("make_hold_invoice", e2, (e3) => !!e3.invoice);
    } catch (e3) {
      throw console.error("Failed to request make_hold_invoice", e3), e3;
    }
  }
  async settleHoldInvoice(e2) {
    try {
      return await this.executeNip47Request("settle_hold_invoice", e2, (e3) => !!e3);
    } catch (e3) {
      throw console.error("Failed to request settle_hold_invoice", e3), e3;
    }
  }
  async cancelHoldInvoice(e2) {
    try {
      return await this.executeNip47Request("cancel_hold_invoice", e2, (e3) => !!e3);
    } catch (e3) {
      throw console.error("Failed to request cancel_hold_invoice", e3), e3;
    }
  }
  async lookupInvoice(e2) {
    try {
      return await this.executeNip47Request("lookup_invoice", e2, (e3) => !!e3.invoice);
    } catch (e3) {
      throw console.error("Failed to request lookup_invoice", e3), e3;
    }
  }
  async listTransactions(e2) {
    try {
      return await this.executeNip47Request("list_transactions", e2, (e3) => !!e3.transactions, { replyTimeout: 1e4 });
    } catch (e3) {
      throw console.error("Failed to request list_transactions", e3), e3;
    }
  }
  async subscribeNotifications(e2, t2) {
    var n2 = this;
    let i3, s2, o2, r2 = true;
    return (async function() {
      for (; r2; ) {
        try {
          await n2._checkConnected(), await n2._selectEncryptionType(), o2 = n2.relay.subscribe([{ kinds: [..."nip04" === n2.encryptionType ? [23196] : [23197]], authors: [n2.walletPubkey], "#p": [n2.publicKey] }], {}), console.info("subscribed to relay"), o2.onevent = async function(i4) {
            const s3 = await n2.decrypt(n2.walletPubkey, i4.content);
            let o3;
            try {
              o3 = JSON.parse(s3);
            } catch (e3) {
              return void console.error("Failed to parse decrypted event content", e3);
            }
            o3.notification ? (!t2 || t2.indexOf(o3.notification_type) > -1) && e2(o3) : console.error("No notification in response", o3);
          }, await new Promise((e3) => {
            i3 = () => {
              e3();
            }, s2 = () => {
              console.info("relay disconnected"), null == i3 || i3();
            }, n2.relay.onclose = s2;
          }), void 0 !== s2 && (n2.relay.onclose = null);
        } catch (e3) {
          console.error("error subscribing to notifications", e3 || "unknown relay error");
        }
        r2 && await new Promise((e3) => setTimeout(e3, 1e3));
      }
    })(), () => {
      var e3;
      r2 = false, null == i3 || i3(), null == (e3 = o2) || e3.close();
    };
  }
  async executeNip47Request(e2, t2, n2, i3) {
    var s2 = this;
    return await this._checkConnected(), await this._selectEncryptionType(), new Promise((o2, r2) => {
      !(async function() {
        const a2 = { method: e2, params: t2 }, c2 = await s2.encrypt(s2.walletPubkey, JSON.stringify(a2)), l2 = { kind: 23194, created_at: Math.floor(Date.now() / 1e3), tags: [["p", s2.walletPubkey], ["v", "nip44_v2" === s2.encryptionType ? "1.0" : "0.0"], ["encryption", s2.encryptionType]], content: c2 }, u2 = await s2.signEvent(l2), h3 = s2.relay.subscribe([{ kinds: [23195], authors: [s2.walletPubkey], "#e": [u2.id] }], {}), d3 = setTimeout(function() {
          h3.close(), r2(new K2(`reply timeout: event ${u2.id}`, "INTERNAL"));
        }, (null == i3 ? void 0 : i3.replyTimeout) || 6e4);
        h3.onevent = async function(e3) {
          clearTimeout(d3), h3.close();
          const t3 = await s2.decrypt(s2.walletPubkey, e3.content);
          let i4;
          try {
            i4 = JSON.parse(t3);
          } catch (e4) {
            return clearTimeout(d3), h3.close(), void r2(new J2("failed to deserialize response", "INTERNAL"));
          }
          var a3, c3;
          i4.result ? n2(i4.result) ? o2(i4.result) : (clearTimeout(d3), h3.close(), r2(new B2("response from NWC failed validation: " + JSON.stringify(i4.result), "INTERNAL"))) : (clearTimeout(d3), h3.close(), r2(new $2((null == (a3 = i4.error) ? void 0 : a3.message) || "unknown Error", (null == (c3 = i4.error) ? void 0 : c3.code) || "INTERNAL")));
        };
        const p3 = setTimeout(function() {
          h3.close(), r2(new L2(`publish timeout: ${u2.id}`, "INTERNAL"));
        }, (null == i3 ? void 0 : i3.publishTimeout) || 5e3);
        try {
          await s2.relay.publish(u2), clearTimeout(p3);
        } catch (e3) {
          clearTimeout(p3), r2(new j2(`failed to publish: ${e3}`, "INTERNAL"));
        }
      })();
    });
  }
  async executeMultiNip47Request(e2, t2, n2, i3, s2) {
    var o2 = this;
    await this._checkConnected(), await this._selectEncryptionType();
    const r2 = [];
    return new Promise((a2, c2) => {
      !(async function() {
        const l2 = { method: e2, params: t2 }, u2 = await o2.encrypt(o2.walletPubkey, JSON.stringify(l2)), d3 = { kind: 23194, created_at: Math.floor(Date.now() / 1e3), tags: [["p", o2.walletPubkey], ["v", "nip44_v2" === o2.encryptionType ? "1.0" : "0.0"], ["encryption", o2.encryptionType]], content: u2 }, p3 = await o2.signEvent(d3), y3 = o2.relay.subscribe([{ kinds: [23195], authors: [o2.walletPubkey], "#e": [p3.id] }], {}), w3 = setTimeout(function() {
          y3.close(), c2(new K2(`reply timeout: event ${p3.id}`, "INTERNAL"));
        }, (null == s2 ? void 0 : s2.replyTimeout) || 6e4);
        y3.onevent = async function(e3) {
          const t3 = await o2.decrypt(o2.walletPubkey, e3.content);
          let s3;
          try {
            s3 = JSON.parse(t3);
          } catch (e4) {
            clearTimeout(w3), y3.close(), c2(new J2("failed to deserialize response", "INTERNAL"));
          }
          if (s3.result) {
            var l3;
            if (!i3(s3.result)) return clearTimeout(w3), y3.close(), void c2(new B2("Response from NWC failed validation: " + JSON.stringify(s3.result), "INTERNAL"));
            const t4 = null == (l3 = e3.tags.find((e4) => "d" === e4[0])) ? void 0 : l3[1];
            if (void 0 === t4) return clearTimeout(w3), y3.close(), void c2(new B2("No d tag found in response event", "INTERNAL"));
            r2.push(h2({}, s3.result, { dTag: t4 })), r2.length === n2 && (clearTimeout(w3), y3.close(), a2(r2));
          } else {
            var u3, d4;
            clearTimeout(w3), y3.close(), c2(new H2(null == (u3 = s3.error) ? void 0 : u3.message, null == (d4 = s3.error) ? void 0 : d4.code));
          }
        };
        const m3 = setTimeout(function() {
          y3.close(), c2(new L2(`Publish timeout: ${p3.id}`, "INTERNAL"));
        }, (null == s2 ? void 0 : s2.publishTimeout) || 5e3);
        try {
          await o2.relay.publish(p3), clearTimeout(m3);
        } catch (e3) {
          clearTimeout(m3), c2(new j2(`Failed to publish: ${e3}`, "INTERNAL"));
        }
      })();
    });
  }
  async _checkConnected() {
    if (!this.secret) throw new Error("Missing secret key");
    if (!this.relayUrl) throw new Error("Missing relay url");
    try {
      this.relay.connected || await this.relay.connect();
    } catch (e2) {
      throw console.error("failed to connect to relay", this.relayUrl), new W2("Failed to connect to " + this.relayUrl, "OTHER");
    }
  }
  async _selectEncryptionType() {
    if (!this._encryptionType) {
      const e2 = await this.getWalletServiceInfo(), t2 = this._findPreferredEncryptionType(e2.encryptions);
      if (!t2) throw new z2("no compatible encryption or version found between wallet and client", "UNSUPPORTED_ENCRYPTION");
      "nip04" === t2 && console.warn("NIP-04 encryption is about to be deprecated. Please upgrade your wallet service to use NIP-44 instead."), this._encryptionType = t2;
    }
  }
  _findPreferredEncryptionType(e2) {
    return e2.includes("nip44_v2") ? "nip44_v2" : e2.includes("nip04") ? "nip04" : null;
  }
};
var G2 = { get_info: "getInfo", get_balance: "getBalance", make_invoice: "makeInvoice", pay_invoice: "sendPayment", pay_keysend: "payKeysend", lookup_invoice: "lookupInvoice", list_transactions: "listTransactions", multi_pay_invoice: "sendMultiPayment", multi_pay_keysend: "multiKeysend", sign_message: "signMessage" };
var V2 = class _V {
  get options() {
    return this.client.options;
  }
  static async fromAuthorizationUrl(e2, t2 = {}, n2) {
    const i3 = await D2.fromAuthorizationUrl(e2, t2, n2);
    return new _V({ client: i3 });
  }
  constructor(e2) {
    this._enabled = false, this.client = void 0, this.subscribers = void 0, this.client = (null == e2 ? void 0 : e2.client) || new D2(e2), this.subscribers = {};
  }
  on(e2, t2) {
    this.subscribers[e2] = t2;
  }
  notify(e2, t2) {
    const n2 = this.subscribers[e2];
    n2 && n2(t2);
  }
  getPublicKey() {
    return this.client.getPublicKey();
  }
  signEvent(e2) {
    return this.client.signEvent(e2);
  }
  async enable() {
    this._enabled = true;
  }
  close() {
    return this.client.close();
  }
  async getInfo() {
    await this.checkEnabled();
    const e2 = ["lightning", "nostr"], t2 = "Alby JS SDK";
    try {
      const n2 = await this.client.getInfo(), i3 = { methods: n2.methods.map((e3) => G2[e3]), node: { alias: n2.alias, pubkey: n2.pubkey, color: n2.color }, supports: e2, version: t2 };
      return this.notify("getInfo", i3), i3;
    } catch (n2) {
      return console.error("Using minimal getInfo", n2), { methods: ["sendPayment"], node: {}, supports: e2, version: t2 };
    }
  }
  async getBalance() {
    await this.checkEnabled();
    const e2 = await this.client.getBalance(), t2 = { balance: Math.floor(e2.balance / 1e3), currency: "sats" };
    return this.notify("getBalance", t2), t2;
  }
  async sendPayment(e2) {
    await this.checkEnabled();
    const t2 = { preimage: (await this.client.payInvoice({ invoice: e2 })).preimage };
    return this.notify("sendPayment", t2), t2;
  }
  async sendPaymentAsync(e2) {
    return await this.checkEnabled(), this.client.payInvoice({ invoice: e2 }), this.notify("sendPaymentAsync", {}), {};
  }
  async keysend(e2) {
    await this.checkEnabled();
    const t2 = { preimage: (await this.client.payKeysend(X2(e2))).preimage };
    return this.notify("keysend", t2), t2;
  }
  async signMessage(e2) {
    await this.checkEnabled();
    const t2 = await this.client.signMessage({ message: e2 }), n2 = { message: t2.message, signature: t2.signature };
    return this.notify("keysend", n2), n2;
  }
  async makeInvoice(e2) {
    var t2;
    await this.checkEnabled();
    const n2 = "object" == typeof e2 ? e2 : void 0, i3 = +(null != (t2 = null == n2 ? void 0 : n2.amount) ? t2 : e2);
    if (!i3) throw new Error("No amount specified");
    const s2 = { paymentRequest: (await this.client.makeInvoice({ amount: 1e3 * i3, description: null == n2 ? void 0 : n2.defaultMemo })).invoice };
    return this.notify("makeInvoice", s2), s2;
  }
  async lookupInvoice(e2) {
    await this.checkEnabled();
    const t2 = await this.client.lookupInvoice({ invoice: e2.paymentRequest, payment_hash: e2.paymentHash }), n2 = { preimage: t2.preimage, paymentRequest: t2.invoice, paid: !!t2.settled_at };
    return this.notify("lookupInvoice", n2), n2;
  }
  async listTransactions(e2) {
    await this.checkEnabled();
    const t2 = { transactions: (await this.client.listTransactions(e2)).transactions.map(Y2) };
    return this.notify("listTransactions", t2), t2;
  }
  async sendMultiPayment(e2) {
    await this.checkEnabled();
    const t2 = await this.client.multiPayInvoice({ invoices: e2.map((e3, t3) => ({ invoice: e3, id: t3.toString() })) }), n2 = { payments: t2.invoices.map((t3) => {
      const n3 = e2[parseInt(t3.dTag)];
      if (!n3) throw new Error("Could not find paymentRequest matching response d tag");
      return { paymentRequest: n3, preimage: t3.preimage };
    }), errors: [] };
    return this.notify("sendMultiPayment", n2), n2;
  }
  async multiKeysend(e2) {
    await this.checkEnabled();
    const t2 = await this.client.multiPayKeysend({ keysends: e2.map((e3, t3) => h2({}, X2(e3), { id: t3.toString() })) }), n2 = { keysends: t2.keysends.map((t3) => {
      const n3 = e2[parseInt(t3.dTag)];
      if (!n3) throw new Error("Could not find keysend matching response d tag");
      return { keysend: n3, preimage: t3.preimage };
    }), errors: [] };
    return this.notify("multiKeysend", n2), n2;
  }
  lnurl(e2) {
    throw new Error("Method not implemented.");
  }
  request(e2, t2) {
    throw new Error("Method not implemented.");
  }
  verifyMessage(e2, t2) {
    throw new Error("Method not implemented.");
  }
  async checkEnabled() {
    if (!this._enabled) throw new Error("please call enable() and await the promise before calling this function");
  }
};
function Y2(e2) {
  return h2({}, e2, { amount: Math.floor(e2.amount / 1e3), fees_paid: e2.fees_paid ? Math.floor(e2.fees_paid / 1e3) : 0 });
}
function X2(e2) {
  return { amount: 1e3 * +e2.amount, pubkey: e2.destination, tlv_records: e2.customRecords ? Object.entries(e2.customRecords).map((e3) => ({ type: parseInt(e3[0]), value: P2(new TextEncoder().encode(e3[1])) })) : [] };
}
var Q = { __proto__: null, NostrWebLNProvider: V2, NWC: V2, OauthWeblnProvider: class {
  constructor(e2) {
    this.client = void 0, this.auth = void 0, this.oauth = void 0, this.subscribers = void 0, this.isExecuting = void 0, this.auth = e2.auth, this.client = new I2(e2.auth), this.oauth = true, this.subscribers = {}, this.isExecuting = false;
  }
  on(e2, t2) {
    this.subscribers[e2] = t2;
  }
  notify(e2, t2) {
    const n2 = this.subscribers[e2];
    n2 && n2(t2);
  }
  async enable() {
    var e2;
    if (!this.isExecuting) {
      if (null != (e2 = this.auth.token) && e2.access_token) return { enabled: true };
      if ("undefined" == typeof window || void 0 === window.document) throw new Error("Missing access token");
      try {
        this.isExecuting = true, await this.openAuthorization();
      } finally {
        this.isExecuting = false;
      }
    }
  }
  async sendPayment(e2) {
    if (!this.isExecuting) try {
      this.isExecuting = true;
      const t2 = await this.client.sendPayment({ invoice: e2 });
      return this.notify("sendPayment", t2), { preimage: t2.payment_preimage };
    } catch (e3) {
      let t2 = "Unknown Error";
      throw e3 instanceof Error && (t2 = e3.message), new Error(t2);
    } finally {
      this.isExecuting = false;
    }
  }
  async keysend(e2) {
    if (!this.isExecuting) try {
      this.isExecuting = true;
      const t2 = await this.client.keysend(e2);
      return this.notify("keysend", t2), { preimage: t2.payment_preimage };
    } catch (e3) {
      let t2 = "Unknown Error";
      throw e3 instanceof Error && (t2 = e3.message), new Error(t2);
    } finally {
      this.isExecuting = false;
    }
  }
  async getInfo() {
    return { alias: "Alby" };
  }
  async makeInvoice(e2) {
    if (!this.isExecuting) try {
      this.isExecuting = true;
      const t2 = await this.client.createInvoice({ amount: parseInt(e2.amount.toString()), description: e2.defaultMemo });
      return this.notify("makeInvoice", t2), { paymentRequest: t2.payment_request };
    } catch (e3) {
      let t2 = "Unknown Error";
      throw e3 instanceof Error && (t2 = e3.message), new Error(t2);
    } finally {
      this.isExecuting = false;
    }
  }
  async openAuthorization() {
    var e2 = this;
    const t2 = window.outerHeight / 2 + window.screenY - 350, n2 = window.outerWidth / 2 + window.screenX - 300, i3 = await this.auth.generateAuthURL({ code_challenge_method: "S256" });
    return new Promise((s2, o2) => {
      const r2 = window.open(i3, `${document.title} - WebLN enable`, `height=700,width=600,top=${t2},left=${n2}`);
      let a2 = false;
      window.addEventListener("message", async function(t3) {
        const n3 = t3.data;
        if (n3 && "alby:oauth:success" === n3.type && t3.origin === `${document.location.protocol}//${document.location.host}` && !a2) {
          a2 = true, console.info("Processing OAuth code response");
          const t4 = n3.payload.code;
          try {
            await e2.auth.requestAccessToken(t4), e2.client = new I2(e2.auth), r2 && r2.close(), e2.notify("enable"), s2({ enabled: true });
          } catch (e3) {
            console.error(e3), o2({ enabled: false });
          }
        }
      });
    });
  }
} };
var Z2 = { __proto__: null, Nip47Error: M2, Nip47NetworkError: W2, Nip47WalletError: $2, Nip47TimeoutError: F2, Nip47PublishTimeoutError: L2, Nip47ReplyTimeoutError: K2, Nip47PublishError: j2, Nip47ResponseDecodingError: J2, Nip47ResponseValidationError: B2, Nip47UnexpectedResponseError: H2, Nip47UnsupportedEncryptionError: z2, NWCClient: D2, NWAClient: class {
  constructor(t2) {
    if (this.options = void 0, this.appSecretKey = void 0, this.relay = void 0, this.appSecretKey = t2.appSecretKey || O2(generateSecretKey()), this.options = h2({}, t2, { appPubkey: getPublicKey(C2(this.appSecretKey)) }), !this.options.relayUrl) throw new Error("Missing relay url");
    if (!this.options.requestMethods) throw new Error("Missing request methods");
    this.relay = new Relay(this.options.relayUrl), void 0 === globalThis.WebSocket && console.error("WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments");
  }
  get connectionUri() {
    return this.getConnectionUri();
  }
  getConnectionUri(e2 = "") {
    const t2 = new URLSearchParams(h2({ relay: this.options.relayUrl, request_methods: this.options.requestMethods.join(" ") }, this.options.name ? { name: this.options.name } : {}, this.options.icon ? { icon: this.options.icon } : {}, this.options.returnTo ? { return_to: this.options.returnTo } : {}, this.options.notificationTypes ? { notification_types: this.options.notificationTypes.join(" ") } : {}, this.options.maxAmount ? { max_amount: this.options.maxAmount.toString() } : {}, this.options.budgetRenewal ? { budget_renewal: this.options.budgetRenewal } : {}, this.options.expiresAt ? { expires_at: this.options.expiresAt.toString() } : {}, this.options.isolated ? { isolated: this.options.isolated.toString() } : {}, this.options.metadata ? { metadata: JSON.stringify(this.options.metadata) } : {}));
    return `nostr+walletauth${e2 ? `+${e2}` : ""}://${this.options.appPubkey}?${t2.toString().replace(/\+/g, "%20")}`;
  }
  static parseWalletAuthUrl(e2) {
    var t2, n2;
    if (!e2.startsWith("nostr+walletauth")) throw new Error("Unexpected scheme. Should be nostr+walletauth:// or nostr+walletauth+specificapp://");
    const i3 = e2.indexOf(":");
    (e2 = e2.substring(i3 + 1)).startsWith("//") && (e2 = e2.substring(2)), e2 = "http://" + e2;
    const s2 = new URL(e2), o2 = s2.host;
    if (64 !== (null == o2 ? void 0 : o2.length)) throw new Error("Incorrect app pubkey found in auth string");
    const r2 = s2.searchParams.get("relay");
    if (!r2) throw new Error("No relay URL found in auth string");
    const a2 = null == (t2 = s2.searchParams.get("request_methods")) ? void 0 : t2.split(" ");
    if (null == a2 || !a2.length) throw new Error("No request methods found in auth string");
    const c2 = null == (n2 = s2.searchParams.get("notification_types")) ? void 0 : n2.split(" "), l2 = s2.searchParams.get("max_amount"), u2 = s2.searchParams.get("expires_at"), h3 = s2.searchParams.get("metadata");
    return { name: s2.searchParams.get("name") || void 0, icon: s2.searchParams.get("icon") || void 0, returnTo: s2.searchParams.get("return_to") || void 0, relayUrl: r2, appPubkey: o2, requestMethods: a2, notificationTypes: c2, budgetRenewal: s2.searchParams.get("budget_renewal"), expiresAt: u2 ? parseInt(u2) : void 0, maxAmount: l2 ? parseInt(l2) : void 0, isolated: "true" === s2.searchParams.get("isolated"), metadata: h3 ? JSON.parse(h3) : void 0 };
  }
  async subscribe(e2) {
    var t2 = this;
    let n2, i3, s2 = true;
    return (async function() {
      for (; s2; ) {
        try {
          await t2._checkConnected();
          const s3 = t2.relay.subscribe([{ kinds: [13194], "#p": [t2.options.appPubkey] }], {});
          console.info("subscribed to relay");
          const o2 = () => {
            s3.close(), t2.relay.close();
          };
          s3.onevent = async function(n3) {
            const i4 = new D2({ relayUrl: t2.options.relayUrl, secret: t2.appSecretKey, walletPubkey: n3.pubkey });
            try {
              const e3 = await i4.getInfo();
              i4.options.lud16 = e3.lud16, i4.lud16 = e3.lud16;
            } catch (e3) {
              console.error("failed to fetch get_info", e3);
            }
            e2.onSuccess(i4), o2();
          }, await new Promise((e3) => {
            n2 = () => {
              e3();
            }, i3 = () => {
              console.info("relay disconnected"), null == n2 || n2();
            }, t2.relay.onclose = i3;
          }), void 0 !== i3 && (t2.relay.onclose = null);
        } catch (e3) {
          console.error("error subscribing to info event", e3 || "unknown relay error");
        }
        s2 && await new Promise((e3) => setTimeout(e3, 1e3));
      }
    })(), { unsub: () => {
      s2 = false, null == n2 || n2();
    } };
  }
  async _checkConnected() {
    if (!this.appSecretKey) throw new Error("Missing secret key");
    if (!this.options.relayUrl) throw new Error("Missing relay url");
    try {
      this.relay.connected || await this.relay.connect();
    } catch (e2) {
      throw console.error("failed to connect to relay", this.options.relayUrl), new W2("Failed to connect to " + this.options.relayUrl, "OTHER");
    }
  }
}, NWCWalletServiceKeyPair: class {
  constructor(e2, t2) {
    if (this.walletSecret = void 0, this.walletPubkey = void 0, this.clientPubkey = void 0, this.walletSecret = e2, this.clientPubkey = t2, !this.walletSecret) throw new Error("Missing wallet secret key");
    if (!this.clientPubkey) throw new Error("Missing client pubkey");
    this.walletPubkey = getPublicKey(C2(this.walletSecret));
  }
}, NWCWalletService: class {
  constructor(t2) {
    this.relay = void 0, this.relayUrl = void 0, this.relayUrl = t2.relayUrl, this.relay = new Relay(this.relayUrl), void 0 === globalThis.WebSocket && console.error("WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments");
  }
  async publishWalletServiceInfoEvent(e2, t2, n2) {
    try {
      await this._checkConnected();
      const i3 = { kind: 13194, created_at: Math.floor(Date.now() / 1e3), tags: [["encryption", "nip04 nip44_v2"], ["notifications", n2.join(" ")]], content: t2.join(" ") }, s2 = await this.signEvent(i3, e2);
      await this.relay.publish(s2);
    } catch (e3) {
      throw console.error("failed to publish wallet service info event", e3), e3;
    }
  }
  async subscribe(e2, t2) {
    var n2 = this;
    let i3, s2, o2, r2 = true;
    return (async function() {
      for (; r2; ) {
        try {
          console.info("checking connection to relay"), await n2._checkConnected(), console.info("subscribing to relay"), o2 = n2.relay.subscribe([{ kinds: [23194], authors: [e2.clientPubkey], "#p": [e2.walletPubkey] }], {}), console.info("subscribed to relay"), o2.onevent = async function(i4) {
            try {
              var s3;
              const o3 = (null == (s3 = i4.tags.find((e3) => "encryption" === e3[0])) ? void 0 : s3[1]) || "nip04", r3 = await n2.decrypt(e2, i4.content, o3), a2 = JSON.parse(r3);
              let c2;
              switch (a2.method) {
                case "get_info":
                  c2 = null == t2.getInfo ? void 0 : t2.getInfo();
                  break;
                case "make_invoice":
                  c2 = null == t2.makeInvoice ? void 0 : t2.makeInvoice(a2.params);
                  break;
                case "pay_invoice":
                  c2 = null == t2.payInvoice ? void 0 : t2.payInvoice(a2.params);
                  break;
                case "pay_keysend":
                  c2 = null == t2.payKeysend ? void 0 : t2.payKeysend(a2.params);
                  break;
                case "get_balance":
                  c2 = null == t2.getBalance ? void 0 : t2.getBalance();
                  break;
                case "lookup_invoice":
                  c2 = null == t2.lookupInvoice ? void 0 : t2.lookupInvoice(a2.params);
                  break;
                case "list_transactions":
                  c2 = null == t2.listTransactions ? void 0 : t2.listTransactions(a2.params);
                  break;
                case "sign_message":
                  c2 = null == t2.signMessage ? void 0 : t2.signMessage(a2.params);
              }
              let l2 = await c2;
              l2 || (console.warn("received unsupported method", a2.method), l2 = { error: { code: "NOT_IMPLEMENTED", message: "This method is not supported by the wallet service" }, result: void 0 });
              const u2 = { kind: 23195, created_at: Math.floor(Date.now() / 1e3), tags: [["e", i4.id]], content: await n2.encrypt(e2, JSON.stringify(h2({ result_type: a2.method }, l2)), o3) }, d3 = await n2.signEvent(u2, e2.walletSecret);
              await n2.relay.publish(d3);
            } catch (e3) {
              return void console.error("Failed to parse decrypted event content", e3);
            }
          }, await new Promise((e3) => {
            i3 = () => {
              e3();
            }, s2 = () => {
              console.error("relay disconnected"), null == i3 || i3();
            }, n2.relay.onclose = s2;
          }), void 0 !== s2 && (n2.relay.onclose = null);
        } catch (e3) {
          console.error("error subscribing to requests", e3 || "unknown relay error");
        }
        r2 && await new Promise((e3) => setTimeout(e3, 1e3));
      }
    })(), () => {
      var e3;
      r2 = false, null == i3 || i3(), null == (e3 = o2) || e3.close();
    };
  }
  get connected() {
    return this.relay.connected;
  }
  signEvent(e2, t2) {
    return Promise.resolve(finalizeEvent(e2, C2(t2)));
  }
  close() {
    return this.relay.close();
  }
  async encrypt(e2, t2, n2) {
    let i3;
    if ("nip04" === n2) i3 = await nip04_exports.encrypt(e2.walletSecret, e2.clientPubkey, t2);
    else {
      const n3 = nip44_exports.getConversationKey(C2(e2.walletSecret), e2.clientPubkey);
      i3 = nip44_exports.encrypt(t2, n3);
    }
    return i3;
  }
  async decrypt(e2, t2, n2) {
    let i3;
    if ("nip04" === n2) i3 = await nip04_exports.decrypt(e2.walletSecret, e2.clientPubkey, t2);
    else {
      const n3 = nip44_exports.getConversationKey(C2(e2.walletSecret), e2.clientPubkey);
      i3 = nip44_exports.decrypt(t2, n3);
    }
    return i3;
  }
  async _checkConnected() {
    if (!this.relayUrl) throw new Error("Missing relay url");
    try {
      this.relay.connected || await this.relay.connect();
    } catch (e2) {
      throw console.error("failed to connect to relay", this.relayUrl), new W2("Failed to connect to " + this.relayUrl, "OTHER");
    }
  }
} };
var ee2 = class {
  constructor(e2, t2) {
    this.transaction = void 0, this.invoice = void 0, this._nwcClient = void 0, this._unsubscribeFunc = void 0, this._timeoutFunc = void 0, this._timeoutId = void 0, this.transaction = t2, this.invoice = new j({ pr: t2.invoice }), this._nwcClient = e2;
  }
  onPaid(e2) {
    var t2 = this;
    return (async function() {
      let n2;
      try {
        var i3;
        n2 = null == (i3 = (await t2._nwcClient.getInfo()).notifications) ? void 0 : i3.includes("payment_received");
      } catch (e3) {
        console.error("failed to fetch info, falling back to polling");
      }
      const s2 = (n3) => {
        null == t2._unsubscribeFunc || t2._unsubscribeFunc(), e2(n3);
      }, o2 = (e3) => () => {
        t2._timeoutFunc = void 0, clearTimeout(t2._timeoutId), e3();
      };
      if (n2) {
        const e3 = (e4) => {
          e4.notification.payment_hash === t2.transaction.payment_hash && s2(e4.notification);
        };
        t2._unsubscribeFunc = o2(await t2._nwcClient.subscribeNotifications(e3, ["payment_received"]));
      } else console.warn("current connection does not support notifications, falling back to polling"), t2._unsubscribeFunc = o2(t2._onPaidPollingFallback(s2));
    })(), this;
  }
  onTimeout(e2, t2) {
    return this._timeoutFunc = () => {
      var e3;
      null == (e3 = this._unsubscribeFunc) || e3.call(this), t2();
    }, this._timeoutId = setTimeout(() => {
      var e3;
      null == (e3 = this._timeoutFunc) || e3.call(this);
    }, 1e3 * e2), this;
  }
  unsubscribe() {
    var e2;
    null == (e2 = this._unsubscribeFunc) || e2.call(this);
  }
  _onPaidPollingFallback(e2) {
    var t2 = this;
    let n2 = true;
    return (async function() {
      for (; n2; ) {
        const i3 = await t2._nwcClient.lookupInvoice({ payment_hash: t2.transaction.payment_hash });
        if (i3.settled_at && i3.preimage) {
          e2(i3), n2 = false;
          break;
        }
        await new Promise((e3) => setTimeout(e3, 3e3));
      }
    })(), () => {
      n2 = false;
    };
  }
};
var te = (e2) => ({ satoshi: e2 });
async function ne2(e2) {
  if ("number" == typeof e2) return { satoshi: e2, millisat: 1e3 * e2 };
  const t2 = await Promise.resolve(e2.satoshi);
  return { satoshi: t2, millisat: 1e3 * t2 };
}
var ie2 = class {
  constructor(e2) {
    this.nwcClient = void 0, this.nwcClient = "string" == typeof e2 ? new D2({ nostrWalletConnectUrl: e2 }) : e2 instanceof D2 ? e2 : new D2(e2);
  }
  async pay(e2, t2, n2) {
    let i3 = e2;
    const s2 = t2 ? await ne2(t2) : void 0;
    if (i3.indexOf("@") > -1) {
      var o2, r2;
      if (!s2) throw new Error("Amount must be provided when paying to a lightning address");
      const t3 = new Y(e2);
      await t3.fetch(), i3 = (await t3.requestInvoice({ satoshi: s2.satoshi, comment: null == n2 || null == (o2 = n2.metadata) ? void 0 : o2.comment, payerdata: null == n2 || null == (r2 = n2.metadata) ? void 0 : r2.payer_data })).paymentRequest;
    }
    const a2 = await this.nwcClient.payInvoice(h2({}, n2 || {}, { invoice: i3, amount: null == s2 ? void 0 : s2.millisat }));
    return h2({}, a2, { invoice: new j({ pr: i3 }) });
  }
  async requestPayment(e2, t2) {
    const n2 = await ne2(e2), i3 = await this.nwcClient.makeInvoice(h2({}, t2 || {}, { amount: n2.millisat }));
    return new ee2(this.nwcClient, i3);
  }
  close() {
    this.nwcClient.close();
  }
};
var se = class {
  constructor(e2, t2) {
    this.satoshi = void 0, this.satoshi = le.getSatoshiValue({ amount: e2, currency: t2 });
  }
};
var oe = (e2) => new se(e2, "USD");
var re = (e2) => new se(e2, "EUR");
var ae2 = (e2) => new se(e2, "JPY");
var ce2 = (e2) => new se(e2, "GBP");
var le2 = (e2) => new se(e2, "CHF");
export {
  le2 as CHF,
  re as EUR,
  se as FiatAmount,
  ce2 as GBP,
  ae2 as JPY,
  ie2 as LN,
  ie2 as LNClient,
  ee2 as ReceiveInvoice,
  te as SATS,
  oe as USD,
  Z2 as nwc,
  A2 as oauth,
  ne2 as resolveAmount,
  Q as webln
};
//# sourceMappingURL=@getalby_sdk.js.map
