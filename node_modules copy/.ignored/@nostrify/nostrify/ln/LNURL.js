import { bech32 } from "@jsr/scure__base";
import { NSchema as n, z } from "../NSchema.js";
/**
 * Represents an LNURL, with methods to fetch details and generate invoices.
 */ export class LNURL {
  /** Underlying HTTP(s) URL of the user. */ url;
  /** Fetch function to use for HTTP requests. */ fetch;
  constructor(/** Underlying HTTP(s) URL of the user. */ url, /** Options for the LNURL class. */ opts){
    this.url = url;
    this.fetch = opts?.fetch ?? globalThis.fetch.bind(globalThis);
  }
  /**
   * Create an LNURL object from a bech32 `lnurl1...` string.
   * Throws if the value is not a valid lnurl.
   */ static fromString(value, opts) {
    if (!n.bech32().safeParse(value).success) {
      throw new Error('Expected a bech32 string starting with "lnurl1"');
    }
    const { prefix, words } = bech32.decode(value, 20000);
    if (prefix !== 'lnurl') {
      throw new Error('Expected a bech32 string starting with "lnurl1"');
    }
    const data = bech32.fromWords(words);
    const url = new URL(new TextDecoder().decode(data));
    return new LNURL(url, opts);
  }
  /**
   * Create an LNURL object from a lightning address (email-like format).
   * Throws if the value is not a valid lightning address.
   */ static fromLightningAddress(ln, opts) {
    if (!z.string().email().safeParse(ln).success) {
      throw new Error('Expected a lightning address in email-like format (eg "example@getalby.com")');
    }
    const [name, host] = ln.split('@');
    const url = new URL(`/.well-known/lnurlp/${name}`, `https://${host}`);
    return new LNURL(url, opts);
  }
  /** Returns the LNURL object as a bech32-encoded `lnurl1...` string. */ toString() {
    const data = new TextEncoder().encode(this.url.toString());
    const words = bech32.toWords(data);
    return bech32.encode('lnurl', words, 20000);
  }
  /** Resolve an LNURL to its details. */ async getDetails(opts) {
    const response = await this.fetch(this.url, opts);
    const json = await response.json();
    return LNURL.lnurlDetailsSchema().parse(json);
  }
  /** Generate an LNURL invoice from the params. */ async getInvoice(opts) {
    const details = await this.getDetails(opts);
    const callback = new URL(details.callback);
    callback.searchParams.set('amount', opts.amount.toString());
    callback.searchParams.set('lnurl', this.toString());
    if (opts.nostr) {
      callback.searchParams.set('nostr', JSON.stringify(opts.nostr));
    }
    const response = await this.fetch(callback, opts);
    const json = await response.json();
    return LNURL.lnurlCallbackSchema().parse(json);
  }
  /** LNURL response schema. */ static lnurlDetailsSchema() {
    return z.object({
      allowsNostr: z.boolean().optional(),
      callback: z.string().url(),
      commentAllowed: z.number().nonnegative().int().optional(),
      maxSendable: z.number().positive().int(),
      minSendable: z.number().positive().int(),
      metadata: z.string(),
      nostrPubkey: n.id().optional(),
      tag: z.literal('payRequest')
    }).superRefine((details, ctx)=>{
      if (details.minSendable > details.maxSendable) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: 'minSendable must be less than or equal to maxSendable',
          path: [
            'minSendable'
          ]
        });
      }
    });
  }
  /** LNURL callback schema. */ static lnurlCallbackSchema() {
    return z.object({
      pr: n.bech32('lnbc'),
      routes: z.tuple([])
    });
  }
}
//# sourceMappingURL=LNURL.js.map