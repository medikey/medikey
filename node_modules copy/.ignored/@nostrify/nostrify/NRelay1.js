var _computedKey;
import { getFilterLimit, matchFilters, verifyEvent as _verifyEvent } from "nostr-tools";
import { ArrayQueue, ExponentialBackoff, WebsocketBuilder, WebsocketEvent } from "websocket-ts";
import { Machina } from "./utils/Machina.js";
import { NSchema as n } from "./NSchema.js";
import { NSet } from "./NSet.js";
_computedKey = Symbol.asyncDispose;
/** Single relay connection over WebSocket. */ export class NRelay1 {
  url;
  opts;
  socket;
  subs;
  closedByUser;
  idleTimer;
  controller;
  ee;
  get subscriptions() {
    return [
      ...this.subs.values()
    ];
  }
  log(log) {
    this.opts.log?.({
      ...log,
      url: this.url
    });
  }
  constructor(url, opts = {}){
    this.url = url;
    this.opts = opts;
    this.subs = new Map();
    this.closedByUser = false;
    this.controller = new AbortController();
    this.ee = new EventTarget();
    this.socket = this.createSocket();
    this.maybeStartIdleTimer();
  }
  /** Create (and open) a WebSocket connection with automatic reconnect. */ createSocket() {
    const { backoff = new ExponentialBackoff(1000) } = this.opts;
    return new WebsocketBuilder(this.url).withBuffer(new ArrayQueue()).withBackoff(backoff === false ? undefined : backoff).onOpen((socket)=>{
      this.log({
        level: 'debug',
        ns: 'relay.ws.state',
        state: 'open',
        readyState: socket.readyState
      });
      for (const req of this.subs.values()){
        this.send(req);
      }
    }).onClose((socket)=>{
      this.log({
        level: 'debug',
        ns: 'relay.ws.state',
        state: 'close',
        readyState: socket.readyState
      });
      // If the connection closes on its own and there are no active subscriptions, let it stay closed.
      if (!this.subs.size) {
        this.socket.close();
      }
    }).onReconnect((socket)=>{
      this.log({
        level: 'debug',
        ns: 'relay.ws.state',
        state: 'reconnect',
        readyState: socket.readyState
      });
    }).onRetry((socket, e)=>{
      this.log({
        level: 'warn',
        ns: 'relay.ws.retry',
        readyState: socket.readyState,
        backoff: e.detail.backoff
      });
    }).onError((socket)=>{
      this.log({
        level: 'error',
        ns: 'relay.ws.error',
        readyState: socket.readyState
      });
    }).onMessage((_socket, e)=>{
      if (typeof e.data !== 'string') {
        this.close();
        return;
      }
      const result = n.json().pipe(n.relayMsg()).safeParse(e.data);
      if (result.success) {
        this.log({
          level: 'trace',
          ns: 'relay.ws.message',
          data: result.data
        });
        this.receive(result.data);
      } else {
        this.log({
          level: 'warn',
          ns: 'relay.ws.message',
          error: result.error
        });
      }
    }).build();
  }
  /** Handle a NIP-01 relay message. */ receive(msg) {
    const { auth, verifyEvent = _verifyEvent } = this.opts;
    switch(msg[0]){
      case 'EVENT':
        if (!verifyEvent(msg[2])) break;
        this.ee.dispatchEvent(new CustomEvent(`sub:${msg[1]}`, {
          detail: msg
        }));
        break;
      case 'EOSE':
        this.ee.dispatchEvent(new CustomEvent(`sub:${msg[1]}`, {
          detail: msg
        }));
        break;
      case 'CLOSED':
        this.subs.delete(msg[1]);
        this.maybeStartIdleTimer();
        this.ee.dispatchEvent(new CustomEvent(`sub:${msg[1]}`, {
          detail: msg
        }));
        this.ee.dispatchEvent(new CustomEvent(`count:${msg[1]}`, {
          detail: msg
        }));
        break;
      case 'OK':
        this.ee.dispatchEvent(new CustomEvent(`ok:${msg[1]}`, {
          detail: msg
        }));
        break;
      case 'NOTICE':
        this.ee.dispatchEvent(new CustomEvent('notice', {
          detail: msg
        }));
        break;
      case 'COUNT':
        this.ee.dispatchEvent(new CustomEvent(`count:${msg[1]}`, {
          detail: msg
        }));
        break;
      case 'AUTH':
        auth?.(msg[1]).then((event)=>this.send([
            'AUTH',
            event
          ])).catch(()=>{});
    }
  }
  /** Send a NIP-01 client message to the relay. */ send(msg) {
    this.log({
      level: 'trace',
      ns: 'relay.ws.send',
      data: msg
    });
    this.wake();
    switch(msg[0]){
      case 'REQ':
        this.subs.set(msg[1], msg);
        break;
      case 'CLOSE':
        this.subs.delete(msg[1]);
        this.maybeStartIdleTimer();
        break;
      case 'EVENT':
      case 'COUNT':
        return this.socket.send(JSON.stringify(msg));
    }
    if (this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(msg));
    }
  }
  async *req(filters, opts = {}) {
    const { signal } = opts;
    const subscriptionId = crypto.randomUUID();
    const msgs = this.on(`sub:${subscriptionId}`, signal);
    const req = [
      'REQ',
      subscriptionId,
      ...filters
    ];
    this.send(req);
    try {
      for await (const msg of msgs){
        if (msg[0] === 'EOSE') yield msg;
        if (msg[0] === 'CLOSED') break;
        if (msg[0] === 'EVENT') {
          if (matchFilters(filters, msg[2])) {
            yield msg;
          } else {
            continue;
          }
        }
      }
    } finally{
      this.send([
        'CLOSE',
        subscriptionId
      ]);
    }
  }
  async query(filters, opts) {
    const events = new NSet();
    const limit = filters.reduce((result, filter)=>result + getFilterLimit(filter), 0);
    if (limit === 0) return [];
    for await (const msg of this.req(filters, opts)){
      if (msg[0] === 'EOSE') break;
      if (msg[0] === 'EVENT') events.add(msg[2]);
      if (msg[0] === 'CLOSED') throw new Error('Subscription closed');
      if (events.size >= limit) {
        break;
      }
    }
    return [
      ...events
    ];
  }
  async event(event, opts) {
    const result = this.once(`ok:${event.id}`, opts?.signal);
    try {
      this.send([
        'EVENT',
        event
      ]);
    } catch (e) {
      result.catch(()=>{});
      throw e;
    }
    const [, , ok, reason] = await result;
    if (!ok) {
      throw new Error(reason);
    }
  }
  async count(filters, opts) {
    const subscriptionId = crypto.randomUUID();
    const result = this.once(`count:${subscriptionId}`, opts?.signal);
    try {
      this.send([
        'COUNT',
        subscriptionId,
        ...filters
      ]);
    } catch (e) {
      result.catch(()=>{});
      throw e;
    }
    const msg = await result;
    switch(msg[0]){
      case 'CLOSED':
        throw new Error('Subscription closed');
      case 'COUNT':
        {
          const [, , count] = msg;
          return count;
        }
    }
  }
  /** Get a stream of EE events. */ async *on(key, signal) {
    const _signal = signal ? AbortSignal.any([
      this.controller.signal,
      signal
    ]) : this.controller.signal;
    if (_signal.aborted) throw this.abortError();
    const machina = new Machina(_signal);
    const onMsg = (e)=>machina.push(e.detail);
    this.ee.addEventListener(key, onMsg);
    try {
      for await (const msg of machina){
        yield msg;
      }
    } finally{
      this.ee.removeEventListener(key, onMsg);
    }
  }
  /** Wait for a single EE event. */ async once(key, signal) {
    for await (const msg of this.on(key, signal)){
      return msg;
    }
    throw new Error('Unreachable');
  }
  abortError() {
    return new DOMException('The signal has been aborted', 'AbortError');
  }
  /** Start the idle time if applicable. */ maybeStartIdleTimer() {
    const { idleTimeout = 30_000 } = this.opts;
    // If the idle timeout is disabled, do nothing.
    if (idleTimeout === false) return;
    // If a timer is already running, let it continue without disruption.
    if (this.idleTimer) return;
    // If there are still subscriptions, the connection is not "idle".
    if (this.subs.size) return;
    // If the connection was manually closed, there's no need to start a timer.
    if (this.closedByUser) return;
    this.log({
      level: 'debug',
      ns: 'relay.idletimer',
      state: 'running',
      timeout: idleTimeout
    });
    this.idleTimer = setTimeout(()=>{
      this.log({
        level: 'debug',
        ns: 'relay.idletimer',
        state: 'aborted',
        timeout: idleTimeout
      });
      this.socket.close();
    }, idleTimeout);
  }
  /** Stop the idle timer. */ stopIdleTimer() {
    this.log({
      level: 'debug',
      ns: 'relay.idletimer',
      state: 'stopped'
    });
    clearTimeout(this.idleTimer);
    this.idleTimer = undefined;
  }
  /** Make a new WebSocket, but only if it was closed by an idle timeout. */ wake() {
    this.stopIdleTimer();
    if (!this.closedByUser && this.socket.closedByUser) {
      this.log({
        level: 'debug',
        ns: 'relay.wake',
        state: 'awoken'
      });
      this.socket = this.createSocket();
    } else if (this.closedByUser || this.socket.closedByUser) {
      this.log({
        level: 'debug',
        ns: 'relay.wake',
        state: 'closed'
      });
    } else {
      this.log({
        level: 'debug',
        ns: 'relay.wake',
        state: 'awake'
      });
    }
  }
  /**
   * Close the relay connection and prevent it from reconnecting.
   * After this you should dispose of the `NRelay1` instance and create a new one to connect again.
   */ async close() {
    this.closedByUser = true;
    this.socket.close();
    this.stopIdleTimer();
    this.controller.abort();
    if (this.socket.readyState !== WebSocket.CLOSED) {
      await new Promise((resolve)=>{
        this.socket.addEventListener(WebsocketEvent.close, resolve, {
          once: true
        });
      });
    }
  }
  async [_computedKey]() {
    await this.close();
  }
}
//# sourceMappingURL=NRelay1.js.map