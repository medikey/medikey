// deno-lint-ignore-file require-await
import { z } from "zod";
import { NSchema as n } from "./NSchema.js";
/** [NIP-46](https://github.com/nostr-protocol/nips/blob/master/46.md) remote signer through a relay. */ export class NConnectSigner {
  relay;
  pubkey;
  signer;
  timeout;
  encryption;
  constructor({ relay, pubkey, signer, timeout, encryption = 'nip44' }){
    this.relay = relay;
    this.pubkey = pubkey;
    this.signer = signer;
    this.timeout = timeout;
    this.encryption = encryption;
  }
  async getPublicKey() {
    return this.cmd('get_public_key', []);
  }
  async signEvent(event) {
    const result = await this.cmd('sign_event', [
      JSON.stringify(event)
    ]);
    return n.json().pipe(n.event()).parse(result);
  }
  async getRelays() {
    const result = await this.cmd('get_relays', []);
    return n.json().pipe(z.record(z.string(), z.object({
      read: z.boolean(),
      write: z.boolean()
    }))).parse(result);
  }
  nip04 = {
    encrypt: async (pubkey, plaintext)=>{
      return this.cmd('nip04_encrypt', [
        pubkey,
        plaintext
      ]);
    },
    decrypt: async (pubkey, ciphertext)=>{
      return this.cmd('nip04_decrypt', [
        pubkey,
        ciphertext
      ]);
    }
  };
  nip44 = {
    encrypt: async (pubkey, plaintext)=>{
      return this.cmd('nip44_encrypt', [
        pubkey,
        plaintext
      ]);
    },
    decrypt: async (pubkey, ciphertext)=>{
      return this.cmd('nip44_decrypt', [
        pubkey,
        ciphertext
      ]);
    }
  };
  /** Send a `connect` command to the relay. It should respond with `ack`. */ async connect(secret) {
    const params = [
      this.pubkey
    ];
    if (secret) {
      params.push(secret);
    }
    return this.cmd('connect', params);
  }
  /** Send a `ping` command to the signer. It should respond with `pong`. */ async ping() {
    return this.cmd('ping', []);
  }
  /** High-level RPC method. Returns the string result, or throws on error. */ async cmd(method, params) {
    const signal = typeof this.timeout === 'number' ? AbortSignal.timeout(this.timeout) : undefined;
    const { result, error } = await this.send({
      id: crypto.randomUUID(),
      method,
      params
    }, {
      signal
    });
    if (error) {
      throw new Error(error);
    }
    return result;
  }
  /** Low-level send method. Deals directly with connect request/response. */ async send(request, opts = {}) {
    const { signal } = opts;
    const event = await this.signer.signEvent({
      kind: 24133,
      content: await this.encrypt(this.pubkey, JSON.stringify(request)),
      created_at: Math.floor(Date.now() / 1000),
      tags: [
        [
          'p',
          this.pubkey
        ]
      ]
    });
    const local = await this.signer.getPublicKey();
    const req = this.relay.req([
      {
        kinds: [
          24133
        ],
        authors: [
          this.pubkey
        ],
        '#p': [
          local
        ]
      }
    ], {
      signal
    });
    // Ensure the REQ is opened before sending the EVENT
    const promise = new Promise((resolve, reject)=>{
      (async ()=>{
        try {
          for await (const msg of req){
            if (msg[0] === 'CLOSED') throw new Error('Subscription closed');
            if (msg[0] === 'EVENT') {
              const event = msg[2];
              const decrypted = await this.decrypt(this.pubkey, event.content);
              const response = n.json().pipe(n.connectResponse()).parse(decrypted);
              if (response.id === request.id) {
                resolve(response);
                return;
              }
            }
          }
        } catch (error) {
          reject(error);
        }
      })();
    });
    await this.relay.event(event, {
      signal
    });
    return promise;
  }
  /** Local encrypt depending on settings. */ async encrypt(pubkey, plaintext) {
    switch(this.encryption){
      case 'nip04':
        return this.signer.nip04.encrypt(pubkey, plaintext);
      case 'nip44':
        return this.signer.nip44.encrypt(pubkey, plaintext);
    }
  }
  /** Local decrypt depending on settings. */ async decrypt(pubkey, ciphertext) {
    switch(this.encryption){
      case 'nip04':
        return this.signer.nip04.decrypt(pubkey, ciphertext);
      case 'nip44':
        return this.signer.nip44.decrypt(pubkey, ciphertext);
    }
  }
}
//# sourceMappingURL=NConnectSigner.js.map