import{Relay as e,nip19 as t,getPublicKey as n,finalizeEvent as i,getEventHash as s,nip04 as o,nip44 as r,generateSecretKey as a}from"nostr-tools";import{Invoice as c,LightningAddress as l,fiat as u}from"@getalby/lightning-tools";function h(){return h=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e},h.apply(this,arguments)}function d(e,t){if(null==e)return{};var n,i,s={},o=Object.keys(e);for(i=0;i<o.length;i++)t.indexOf(n=o[i])>=0||(s[n]=e[n]);return s}class p{constructor(){this.events={}}on(e,t){this.events[e]||(this.events[e]=[]),this.events[e].push(t)}off(e,t){this.events[e]&&(this.events[e]=this.events[e].filter(e=>e!==t))}emit(e,t){this.events[e]&&this.events[e].forEach(e=>e(t))}}function y(e){return Object.entries(e).map(([e,t])=>e&&t?`${e}=${t}`:"").filter(e=>e).join("&")}function w(e,t){return`Basic ${btoa(`${e}:${t}`)}`}var m={__proto__:null,buildQueryString:y,basicAuthHeader:w};class f extends Error{constructor(e,t,n,i){let s=e.toString();t&&(s+=` ${t}`),s+=": ",s+=i.message?i.message:JSON.stringify(i),super(s),this.status=void 0,this.statusText=void 0,this.headers=void 0,this.error=void 0,this.status=e,this.statusText=t,this.headers=n,this.error=i}}var g={__proto__:null,OAuthClient:class{},AuthClient:class{},AlbyResponseError:f};const v=["auth","endpoint","params","request_body","method","max_retries","base_url","user_agent","headers"],_="https://api.getalby.com";async function b(e,t,n=0){const i=await fetch(e,t);if(429===i.status&&n>0){const s=Number(i.headers.get("x-rate-limit-reset")),o=Number(i.headers.get("x-rate-limit-remaining")),r=1e3*s-Date.now();let a=1e3;return 0===o&&(a=r),await new Promise(e=>setTimeout(e,a)),b(e,t,n-1)}return i}async function k(e){let{auth:t,endpoint:n,params:i={},request_body:s,method:o,max_retries:r,base_url:a=_,user_agent:c,headers:l}=e,u=d(e,v);const p=new URL(a+n);p.search=y(i);const w="POST"===o&&!!s,m=t?await t.getAuthHeader(p.href,o):void 0,g=await b(p.toString(),h({headers:h({},w?{"Content-Type":"application/json; charset=utf-8"}:void 0,m,l,{"User-Agent":null!=c?c:"@getalby/sdk","X-User-Agent":null!=c?c:"@getalby/sdk"}),method:o,body:w?JSON.stringify(s):void 0},u),r);if(!g.ok){const e=await g.json();throw new f(g.status,g.statusText,g.headers,e)}return g}async function E(e){return(await k(e)).json()}const P=e=>e.reduce((e,t)=>e+t.toString(16).padStart(2,"0"),""),T=["expires_in"],N=["token"];function q(e){const{expires_in:t}=e;return h({},d(e,T),!!t&&{expires_at:Date.now()+1e3*t})}class x{constructor(e){this.bearer_token=void 0,this.bearer_token=e}getAuthHeader(){return{Authorization:`Bearer ${this.bearer_token}`}}}var R={__proto__:null,OAuth2User:class{constructor(e){this.token=void 0,this.options=void 0,this.code_verifier=void 0,this.code_challenge=void 0,this._refreshAccessTokenPromise=void 0,this._tokenEvents=void 0,this._tokenEvents=new p;const{token:t}=e,n=d(e,N);this.options=h({client_secret:""},n),this.token=t,this._refreshAccessTokenPromise=null}on(e,t){this._tokenEvents.on(e,t)}async refreshAccessToken(){var e=this;return this._refreshAccessTokenPromise||(this._refreshAccessTokenPromise=new Promise(async function(t,n){try{var i;const n=null==(i=e.token)?void 0:i.refresh_token,{client_id:s,client_secret:o,request_options:r,user_agent:a}=e.options;if(!s)throw new Error("client_id is required");if(!n)throw new Error("refresh_token is required");const c=q(await E(h({},r,{endpoint:"/oauth/token",params:{client_id:s,grant_type:"refresh_token",refresh_token:n},user_agent:a,method:"POST",headers:h({},null==r?void 0:r.headers,{"Content-type":"application/x-www-form-urlencoded"},{Authorization:w(s,o)})})));e.token=c,t({token:c}),e._tokenEvents.emit("tokenRefreshed",e.token)}catch(t){console.error(t),n(t),e._tokenEvents.emit("tokenRefreshFailed",t)}finally{e._refreshAccessTokenPromise=null}})),this._refreshAccessTokenPromise}isAccessTokenExpired(){var e,t;const n=null==(e=this.token)?void 0:e.refresh_token,i=null==(t=this.token)?void 0:t.expires_at;return!i||!!n&&i<=Date.now()+1e3}async requestAccessToken(e){const{client_id:t,client_secret:n,callback:i,request_options:s,user_agent:o}=this.options,r=this.code_verifier;if(!t)throw new Error("client_id is required");if(!n&&!r)throw new Error("either client_secret is required, or code should be generated using a challenge");if(!i)throw new Error("callback is required");const a={code:e,grant_type:"authorization_code",code_verifier:r,client_id:t,redirect_uri:i},c=q(await E(h({},s,{endpoint:"/oauth/token",params:a,user_agent:o,method:"POST",headers:h({},null==s?void 0:s.headers,{"Content-Type":"application/x-www-form-urlencoded"},{Authorization:w(t,n)})})));return this.token=c,{token:c}}async generateAuthURL(e){e||(e={});const{client_id:t,callback:n,scopes:i}=this.options;if(!n)throw new Error("callback required");if(!i)throw new Error("scopes required");let s;"S256"===e.code_challenge_method?(await this._generateS256Challenge(),s="S256"):"plain"===e.code_challenge_method&&e.code_challenge&&(this.code_challenge=e.code_challenge,this.code_verifier=e.code_challenge,s="plain");const o=this.code_challenge,r=new URL(e.authorizeUrl||"https://getalby.com/oauth");return r.search=y(h({},e,{client_id:t,scope:i.join(" "),response_type:"code",redirect_uri:n,code_challenge_method:s,code_challenge:o})),r.toString()}async getAuthHeader(){var e;if(null==(e=this.token)||!e.access_token)throw new Error("access_token is required");return this.isAccessTokenExpired()&&await this.refreshAccessToken(),{Authorization:`Bearer ${this.token.access_token}`}}async _generateS256Challenge(){const e=crypto.getRandomValues(new Uint8Array(64));this.code_verifier=P(e);const t=await crypto.subtle.digest("SHA-256",(new TextEncoder).encode(this.code_verifier)),n=new Uint8Array(t);this.code_challenge=btoa(String.fromCharCode(...n)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}},OAuth2Bearer:x};function S(e){const t={};return e.recipient.customKey&&e.recipient.customValue&&(t[e.recipient.customKey]=e.recipient.customValue),t[7629169]=JSON.stringify(e.boostagram),{destination:e.recipient.address,amount:e.amount,custom_records:t}}class I{constructor(e,t){this.auth=void 0,this.defaultRequestOptions=void 0,this.auth="string"==typeof e?new x(e):e,this.defaultRequestOptions=h({},t,{user_agent:null==t?void 0:t.user_agent})}accountBalance(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/balance",params:e,method:"GET"}))}signMessage(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/signatures",request_body:e,method:"POST"}))}accountSummary(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/user/summary",params:e,method:"GET"}))}accountInformation(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/user/me",params:e,method:"GET"}))}accountValue4Value(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/user/value4value",params:e,method:"GET"}))}incomingInvoices(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/invoices/incoming",params:e,method:"GET"}))}outgoingInvoices(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/invoices/outgoing",params:e,method:"GET"}))}invoices(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/invoices",params:e,method:"GET"}))}getInvoice(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:`/invoices/${e}`,method:"GET"}))}decodeInvoice(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:`/decode/bolt11/${e}`,method:"GET"}))}createInvoice(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/invoices",request_body:e,method:"POST"}))}keysend(e,t){let n,i;return Array.isArray(e)?(n="/payments/keysend/multi",i={keysends:e.map(e=>h({},e,{custom_records:e.customRecords}))}):(n="/payments/keysend",i=h({},e,{custom_records:e.customRecords})),E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:n,request_body:i,method:"POST"}))}sendPayment(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/payments/bolt11",request_body:e,method:"POST"}))}sendBoostagram(e,t){let n,i;return Array.isArray(e)?(n="/payments/keysend/multi",i={keysends:e.map(e=>S(e))}):(n="/payments/keysend",i=S(e)),E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:n,request_body:i,method:"POST"}))}sendBoostagramToAlbyAccount(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/payments/keysend",request_body:{destination:"030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3",custom_records:{696969:e.account},amount:e.amount,memo:e.memo},method:"POST"}))}createWebhookEndpoint(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/webhook_endpoints",request_body:e,method:"POST"}))}deleteWebhookEndpoint(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:`/webhook_endpoints/${e}`,method:"DELETE"}))}getSwapInfo(e){return E(h({auth:this.auth},this.defaultRequestOptions,e,{endpoint:"/swaps/info",method:"GET"}))}createSwap(e,t){return E(h({auth:this.auth},this.defaultRequestOptions,t,{endpoint:"/swaps",method:"POST",request_body:e}))}}var A={__proto__:null,auth:R,types:g,utils:m,Client:I};if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");const U=/* @__PURE__ */Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function O(e){if(!(e instanceof Uint8Array))throw new Error("Uint8Array expected");let t="";for(let n=0;n<e.length;n++)t+=U[e[n]];return t}function C(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(t/2);for(let t=0;t<n.length;t++){const i=2*t,s=e.slice(i,i+2),o=Number.parseInt(s,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");n[t]=o}return n}class M extends Error{constructor(e,t){super(e),this.code=void 0,this.code=t}}class W extends M{}class $ extends M{}class F extends M{}class L extends F{}class K extends F{}class j extends M{}class J extends M{}class B extends M{}class H extends M{}class z extends M{}class D{static parseWalletConnectUrl(e){e=e.replace("nostrwalletconnect://","http://").replace("nostr+walletconnect://","http://").replace("nostrwalletconnect:","http://").replace("nostr+walletconnect:","http://");const t=new URL(e),n=t.searchParams.get("relay");if(!n)throw new Error("No relay URL found in connection string");const i={walletPubkey:t.host,relayUrl:n},s=t.searchParams.get("secret");s&&(i.secret=s);const o=t.searchParams.get("lud16");return o&&(i.lud16=o),i}constructor(n){this.relay=void 0,this.relayUrl=void 0,this.secret=void 0,this.lud16=void 0,this.walletPubkey=void 0,this.options=void 0,this._encryptionType=void 0,n&&n.nostrWalletConnectUrl&&(n=h({},D.parseWalletConnectUrl(n.nostrWalletConnectUrl),n)),this.options=h({},n||{}),this.relayUrl=this.options.relayUrl,this.relay=new e(this.relayUrl),this.options.secret&&(this.secret=this.options.secret.toLowerCase().startsWith("nsec")?t.decode(this.options.secret).data:this.options.secret),this.lud16=this.options.lud16,this.walletPubkey=this.options.walletPubkey.toLowerCase().startsWith("npub")?t.decode(this.options.walletPubkey).data:this.options.walletPubkey,void 0===globalThis.WebSocket&&console.error("WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments")}get nostrWalletConnectUrl(){return this.getNostrWalletConnectUrl()}getNostrWalletConnectUrl(e=!0){let t=`nostr+walletconnect://${this.walletPubkey}?relay=${this.relayUrl}&pubkey=${this.publicKey}`;return e&&(t=`${t}&secret=${this.secret}`),t}get connected(){return this.relay.connected}get publicKey(){if(!this.secret)throw new Error("Missing secret key");return n(C(this.secret))}get encryptionType(){if(!this._encryptionType)throw new Error("Missing encryption or version");return this._encryptionType}getPublicKey(){return Promise.resolve(this.publicKey)}signEvent(e){if(!this.secret)throw new Error("Missing secret key");return Promise.resolve(i(e,C(this.secret)))}getEventHash(e){return s(e)}close(){return this.relay.close()}async encrypt(e,t){if(!this.secret)throw new Error("Missing secret");let n;if("nip04"===this.encryptionType)n=await o.encrypt(this.secret,e,t);else{const i=r.getConversationKey(C(this.secret),e);n=r.encrypt(t,i)}return n}async decrypt(e,t){if(!this.secret)throw new Error("Missing secret");let n;if("nip04"===this.encryptionType)n=await o.decrypt(this.secret,e,t);else{const i=r.getConversationKey(C(this.secret),e);n=r.decrypt(t,i)}return n}static getAuthorizationUrl(e,t={},n){if(e.indexOf("/#/")>-1)throw new Error("hash router paths not supported");const i=new URL(e);return t.name&&i.searchParams.set("name",t.name),i.searchParams.set("pubkey",n),t.returnTo&&i.searchParams.set("return_to",t.returnTo),t.budgetRenewal&&i.searchParams.set("budget_renewal",t.budgetRenewal),t.expiresAt&&i.searchParams.set("expires_at",Math.floor(t.expiresAt.getTime()/1e3).toString()),t.maxAmount&&i.searchParams.set("max_amount",t.maxAmount.toString()),t.requestMethods&&i.searchParams.set("request_methods",t.requestMethods.join(" ")),t.notificationTypes&&i.searchParams.set("notification_types",t.notificationTypes.join(" ")),t.isolated&&i.searchParams.set("isolated","true"),t.metadata&&i.searchParams.set("metadata",JSON.stringify(t.metadata)),i}static fromAuthorizationUrl(e,t={},i){i=i||O(a()),t.name||(t.name=document.location.host);const s=this.getAuthorizationUrl(e,t,n(C(i))),o=window.outerHeight/2+window.screenY-300,r=window.outerWidth/2+window.screenX-200;return new Promise((e,t)=>{const n=window.open(s.toString(),`${document.title} - Wallet Connect`,`height=600,width=400,top=${o},left=${r}`);if(!n)return void t(new Error("failed to execute window.open"));const a=o=>{const r=o.data;r&&"nwc:success"===r.type&&o.origin===`${s.protocol}//${s.host}`&&(r.relayUrl||t(new Error("no relayUrl in response")),r.walletPubkey||t(new Error("no walletPubkey in response")),e(new D({relayUrl:r.relayUrl,walletPubkey:r.walletPubkey,secret:i,lud16:r.lud16})),clearInterval(c),window.removeEventListener("message",a),n&&n.close())},c=setInterval(()=>{n&&n.closed&&(clearInterval(c),window.removeEventListener("message",a),t(new Error("Popup closed")))},500);window.addEventListener("message",a)})}async getWalletServiceInfo(){var e;await this._checkConnected();const t=await new Promise((e,t)=>{const n=[],i=this.relay.subscribe([{kinds:[13194],limit:1,authors:[this.walletPubkey]}],{eoseTimeout:1e4});i.onevent=e=>{n.push(e)},i.oneose=()=>{i.close(),e(n)}});if(!t.length)throw new Error("no info event (kind 13194) returned from relay");const n=t[0].content,i=t[0].tags.find(e=>"notifications"===e[0]),s=t[0].tags.find(e=>"v"===e[0]),o=t[0].tags.find(e=>"encryption"===e[0]);let r=["nip04"];return s&&s[1].includes("1.0")&&r.push("nip44_v2"),o&&(r=o[1].split(" ")),{encryptions:r,capabilities:n.split(/[ |,]/g),notifications:(null==i||null==(e=i[1])?void 0:e.split(" "))||[]}}async getInfo(){try{return await this.executeNip47Request("get_info",{},e=>!!e.methods,{replyTimeout:1e4})}catch(e){throw console.error("Failed to request get_info",e),e}}async getBudget(){try{return await this.executeNip47Request("get_budget",{},e=>void 0!==e,{replyTimeout:1e4})}catch(e){throw console.error("Failed to request get_budget",e),e}}async getBalance(){try{return await this.executeNip47Request("get_balance",{},e=>void 0!==e.balance,{replyTimeout:1e4})}catch(e){throw console.error("Failed to request get_balance",e),e}}async payInvoice(e){try{return await this.executeNip47Request("pay_invoice",e,e=>!!e)}catch(e){throw console.error("Failed to request pay_invoice",e),e}}async payKeysend(e){try{return await this.executeNip47Request("pay_keysend",e,e=>!!e.preimage)}catch(e){throw console.error("Failed to request pay_keysend",e),e}}async signMessage(e){try{return await this.executeNip47Request("sign_message",e,t=>t.message===e.message&&!!t.signature)}catch(e){throw console.error("Failed to request sign_message",e),e}}async createConnection(e){try{return await this.executeNip47Request("create_connection",e,e=>!!e.wallet_pubkey)}catch(e){throw console.error("Failed to request create_connection",e),e}}async multiPayInvoice(e){try{return{invoices:await this.executeMultiNip47Request("multi_pay_invoice",e,e.invoices.length,e=>!!e.preimage),errors:[]}}catch(e){throw console.error("Failed to request multi_pay_invoice",e),e}}async multiPayKeysend(e){try{return{keysends:await this.executeMultiNip47Request("multi_pay_keysend",e,e.keysends.length,e=>!!e.preimage),errors:[]}}catch(e){throw console.error("Failed to request multi_pay_keysend",e),e}}async makeInvoice(e){try{if(!e.amount)throw new Error("No amount specified");return await this.executeNip47Request("make_invoice",e,e=>!!e.invoice)}catch(e){throw console.error("Failed to request make_invoice",e),e}}async makeHoldInvoice(e){try{if(!e.amount)throw new Error("No amount specified");if(!e.payment_hash)throw new Error("No payment hash specified");return await this.executeNip47Request("make_hold_invoice",e,e=>!!e.invoice)}catch(e){throw console.error("Failed to request make_hold_invoice",e),e}}async settleHoldInvoice(e){try{return await this.executeNip47Request("settle_hold_invoice",e,e=>!!e)}catch(e){throw console.error("Failed to request settle_hold_invoice",e),e}}async cancelHoldInvoice(e){try{return await this.executeNip47Request("cancel_hold_invoice",e,e=>!!e)}catch(e){throw console.error("Failed to request cancel_hold_invoice",e),e}}async lookupInvoice(e){try{return await this.executeNip47Request("lookup_invoice",e,e=>!!e.invoice)}catch(e){throw console.error("Failed to request lookup_invoice",e),e}}async listTransactions(e){try{return await this.executeNip47Request("list_transactions",e,e=>!!e.transactions,{replyTimeout:1e4})}catch(e){throw console.error("Failed to request list_transactions",e),e}}async subscribeNotifications(e,t){var n=this;let i,s,o,r=!0;return async function(){for(;r;){try{await n._checkConnected(),await n._selectEncryptionType(),o=n.relay.subscribe([{kinds:[..."nip04"===n.encryptionType?[23196]:[23197]],authors:[n.walletPubkey],"#p":[n.publicKey]}],{}),console.info("subscribed to relay"),o.onevent=async function(i){const s=await n.decrypt(n.walletPubkey,i.content);let o;try{o=JSON.parse(s)}catch(e){return void console.error("Failed to parse decrypted event content",e)}o.notification?(!t||t.indexOf(o.notification_type)>-1)&&e(o):console.error("No notification in response",o)},await new Promise(e=>{i=()=>{e()},s=()=>{console.info("relay disconnected"),null==i||i()},n.relay.onclose=s}),void 0!==s&&(n.relay.onclose=null)}catch(e){console.error("error subscribing to notifications",e||"unknown relay error")}r&&await new Promise(e=>setTimeout(e,1e3))}}(),()=>{var e;r=!1,null==i||i(),null==(e=o)||e.close()}}async executeNip47Request(e,t,n,i){var s=this;return await this._checkConnected(),await this._selectEncryptionType(),new Promise((o,r)=>{!async function(){const a={method:e,params:t},c=await s.encrypt(s.walletPubkey,JSON.stringify(a)),l={kind:23194,created_at:Math.floor(Date.now()/1e3),tags:[["p",s.walletPubkey],["v","nip44_v2"===s.encryptionType?"1.0":"0.0"],["encryption",s.encryptionType]],content:c},u=await s.signEvent(l),h=s.relay.subscribe([{kinds:[23195],authors:[s.walletPubkey],"#e":[u.id]}],{}),d=setTimeout(function(){h.close(),r(new K(`reply timeout: event ${u.id}`,"INTERNAL"))},(null==i?void 0:i.replyTimeout)||6e4);h.onevent=async function(e){clearTimeout(d),h.close();const t=await s.decrypt(s.walletPubkey,e.content);let i;try{i=JSON.parse(t)}catch(e){return clearTimeout(d),h.close(),void r(new J("failed to deserialize response","INTERNAL"))}var a,c;i.result?n(i.result)?o(i.result):(clearTimeout(d),h.close(),r(new B("response from NWC failed validation: "+JSON.stringify(i.result),"INTERNAL"))):(clearTimeout(d),h.close(),r(new $((null==(a=i.error)?void 0:a.message)||"unknown Error",(null==(c=i.error)?void 0:c.code)||"INTERNAL")))};const p=setTimeout(function(){h.close(),r(new L(`publish timeout: ${u.id}`,"INTERNAL"))},(null==i?void 0:i.publishTimeout)||5e3);try{await s.relay.publish(u),clearTimeout(p)}catch(e){clearTimeout(p),r(new j(`failed to publish: ${e}`,"INTERNAL"))}}()})}async executeMultiNip47Request(e,t,n,i,s){var o=this;await this._checkConnected(),await this._selectEncryptionType();const r=[];return new Promise((a,c)=>{!async function(){const l={method:e,params:t},u=await o.encrypt(o.walletPubkey,JSON.stringify(l)),d={kind:23194,created_at:Math.floor(Date.now()/1e3),tags:[["p",o.walletPubkey],["v","nip44_v2"===o.encryptionType?"1.0":"0.0"],["encryption",o.encryptionType]],content:u},p=await o.signEvent(d),y=o.relay.subscribe([{kinds:[23195],authors:[o.walletPubkey],"#e":[p.id]}],{}),w=setTimeout(function(){y.close(),c(new K(`reply timeout: event ${p.id}`,"INTERNAL"))},(null==s?void 0:s.replyTimeout)||6e4);y.onevent=async function(e){const t=await o.decrypt(o.walletPubkey,e.content);let s;try{s=JSON.parse(t)}catch(e){clearTimeout(w),y.close(),c(new J("failed to deserialize response","INTERNAL"))}if(s.result){var l;if(!i(s.result))return clearTimeout(w),y.close(),void c(new B("Response from NWC failed validation: "+JSON.stringify(s.result),"INTERNAL"));const t=null==(l=e.tags.find(e=>"d"===e[0]))?void 0:l[1];if(void 0===t)return clearTimeout(w),y.close(),void c(new B("No d tag found in response event","INTERNAL"));r.push(h({},s.result,{dTag:t})),r.length===n&&(clearTimeout(w),y.close(),a(r))}else{var u,d;clearTimeout(w),y.close(),c(new H(null==(u=s.error)?void 0:u.message,null==(d=s.error)?void 0:d.code))}};const m=setTimeout(function(){y.close(),c(new L(`Publish timeout: ${p.id}`,"INTERNAL"))},(null==s?void 0:s.publishTimeout)||5e3);try{await o.relay.publish(p),clearTimeout(m)}catch(e){clearTimeout(m),c(new j(`Failed to publish: ${e}`,"INTERNAL"))}}()})}async _checkConnected(){if(!this.secret)throw new Error("Missing secret key");if(!this.relayUrl)throw new Error("Missing relay url");try{this.relay.connected||await this.relay.connect()}catch(e){throw console.error("failed to connect to relay",this.relayUrl),new W("Failed to connect to "+this.relayUrl,"OTHER")}}async _selectEncryptionType(){if(!this._encryptionType){const e=await this.getWalletServiceInfo(),t=this._findPreferredEncryptionType(e.encryptions);if(!t)throw new z("no compatible encryption or version found between wallet and client","UNSUPPORTED_ENCRYPTION");"nip04"===t&&console.warn("NIP-04 encryption is about to be deprecated. Please upgrade your wallet service to use NIP-44 instead."),this._encryptionType=t}}_findPreferredEncryptionType(e){return e.includes("nip44_v2")?"nip44_v2":e.includes("nip04")?"nip04":null}}const G={get_info:"getInfo",get_balance:"getBalance",make_invoice:"makeInvoice",pay_invoice:"sendPayment",pay_keysend:"payKeysend",lookup_invoice:"lookupInvoice",list_transactions:"listTransactions",multi_pay_invoice:"sendMultiPayment",multi_pay_keysend:"multiKeysend",sign_message:"signMessage"};class V{get options(){return this.client.options}static async fromAuthorizationUrl(e,t={},n){const i=await D.fromAuthorizationUrl(e,t,n);return new V({client:i})}constructor(e){this._enabled=!1,this.client=void 0,this.subscribers=void 0,this.client=(null==e?void 0:e.client)||new D(e),this.subscribers={}}on(e,t){this.subscribers[e]=t}notify(e,t){const n=this.subscribers[e];n&&n(t)}getPublicKey(){return this.client.getPublicKey()}signEvent(e){return this.client.signEvent(e)}async enable(){this._enabled=!0}close(){return this.client.close()}async getInfo(){await this.checkEnabled();const e=["lightning","nostr"],t="Alby JS SDK";try{const n=await this.client.getInfo(),i={methods:n.methods.map(e=>G[e]),node:{alias:n.alias,pubkey:n.pubkey,color:n.color},supports:e,version:t};return this.notify("getInfo",i),i}catch(n){return console.error("Using minimal getInfo",n),{methods:["sendPayment"],node:{},supports:e,version:t}}}async getBalance(){await this.checkEnabled();const e=await this.client.getBalance(),t={balance:Math.floor(e.balance/1e3),currency:"sats"};return this.notify("getBalance",t),t}async sendPayment(e){await this.checkEnabled();const t={preimage:(await this.client.payInvoice({invoice:e})).preimage};return this.notify("sendPayment",t),t}async sendPaymentAsync(e){return await this.checkEnabled(),this.client.payInvoice({invoice:e}),this.notify("sendPaymentAsync",{}),{}}async keysend(e){await this.checkEnabled();const t={preimage:(await this.client.payKeysend(X(e))).preimage};return this.notify("keysend",t),t}async signMessage(e){await this.checkEnabled();const t=await this.client.signMessage({message:e}),n={message:t.message,signature:t.signature};return this.notify("keysend",n),n}async makeInvoice(e){var t;await this.checkEnabled();const n="object"==typeof e?e:void 0,i=+(null!=(t=null==n?void 0:n.amount)?t:e);if(!i)throw new Error("No amount specified");const s={paymentRequest:(await this.client.makeInvoice({amount:1e3*i,description:null==n?void 0:n.defaultMemo})).invoice};return this.notify("makeInvoice",s),s}async lookupInvoice(e){await this.checkEnabled();const t=await this.client.lookupInvoice({invoice:e.paymentRequest,payment_hash:e.paymentHash}),n={preimage:t.preimage,paymentRequest:t.invoice,paid:!!t.settled_at};return this.notify("lookupInvoice",n),n}async listTransactions(e){await this.checkEnabled();const t={transactions:(await this.client.listTransactions(e)).transactions.map(Y)};return this.notify("listTransactions",t),t}async sendMultiPayment(e){await this.checkEnabled();const t=await this.client.multiPayInvoice({invoices:e.map((e,t)=>({invoice:e,id:t.toString()}))}),n={payments:t.invoices.map(t=>{const n=e[parseInt(t.dTag)];if(!n)throw new Error("Could not find paymentRequest matching response d tag");return{paymentRequest:n,preimage:t.preimage}}),errors:[]};return this.notify("sendMultiPayment",n),n}async multiKeysend(e){await this.checkEnabled();const t=await this.client.multiPayKeysend({keysends:e.map((e,t)=>h({},X(e),{id:t.toString()}))}),n={keysends:t.keysends.map(t=>{const n=e[parseInt(t.dTag)];if(!n)throw new Error("Could not find keysend matching response d tag");return{keysend:n,preimage:t.preimage}}),errors:[]};return this.notify("multiKeysend",n),n}lnurl(e){throw new Error("Method not implemented.")}request(e,t){throw new Error("Method not implemented.")}verifyMessage(e,t){throw new Error("Method not implemented.")}async checkEnabled(){if(!this._enabled)throw new Error("please call enable() and await the promise before calling this function")}}function Y(e){return h({},e,{amount:Math.floor(e.amount/1e3),fees_paid:e.fees_paid?Math.floor(e.fees_paid/1e3):0})}function X(e){return{amount:1e3*+e.amount,pubkey:e.destination,tlv_records:e.customRecords?Object.entries(e.customRecords).map(e=>({type:parseInt(e[0]),value:P((new TextEncoder).encode(e[1]))})):[]}}var Q={__proto__:null,NostrWebLNProvider:V,NWC:V,OauthWeblnProvider:class{constructor(e){this.client=void 0,this.auth=void 0,this.oauth=void 0,this.subscribers=void 0,this.isExecuting=void 0,this.auth=e.auth,this.client=new I(e.auth),this.oauth=!0,this.subscribers={},this.isExecuting=!1}on(e,t){this.subscribers[e]=t}notify(e,t){const n=this.subscribers[e];n&&n(t)}async enable(){var e;if(!this.isExecuting){if(null!=(e=this.auth.token)&&e.access_token)return{enabled:!0};if("undefined"==typeof window||void 0===window.document)throw new Error("Missing access token");try{this.isExecuting=!0,await this.openAuthorization()}finally{this.isExecuting=!1}}}async sendPayment(e){if(!this.isExecuting)try{this.isExecuting=!0;const t=await this.client.sendPayment({invoice:e});return this.notify("sendPayment",t),{preimage:t.payment_preimage}}catch(e){let t="Unknown Error";throw e instanceof Error&&(t=e.message),new Error(t)}finally{this.isExecuting=!1}}async keysend(e){if(!this.isExecuting)try{this.isExecuting=!0;const t=await this.client.keysend(e);return this.notify("keysend",t),{preimage:t.payment_preimage}}catch(e){let t="Unknown Error";throw e instanceof Error&&(t=e.message),new Error(t)}finally{this.isExecuting=!1}}async getInfo(){return{alias:"Alby"}}async makeInvoice(e){if(!this.isExecuting)try{this.isExecuting=!0;const t=await this.client.createInvoice({amount:parseInt(e.amount.toString()),description:e.defaultMemo});return this.notify("makeInvoice",t),{paymentRequest:t.payment_request}}catch(e){let t="Unknown Error";throw e instanceof Error&&(t=e.message),new Error(t)}finally{this.isExecuting=!1}}async openAuthorization(){var e=this;const t=window.outerHeight/2+window.screenY-350,n=window.outerWidth/2+window.screenX-300,i=await this.auth.generateAuthURL({code_challenge_method:"S256"});return new Promise((s,o)=>{const r=window.open(i,`${document.title} - WebLN enable`,`height=700,width=600,top=${t},left=${n}`);let a=!1;window.addEventListener("message",async function(t){const n=t.data;if(n&&"alby:oauth:success"===n.type&&t.origin===`${document.location.protocol}//${document.location.host}`&&!a){a=!0,console.info("Processing OAuth code response");const t=n.payload.code;try{await e.auth.requestAccessToken(t),e.client=new I(e.auth),r&&r.close(),e.notify("enable"),s({enabled:!0})}catch(e){console.error(e),o({enabled:!1})}}})})}}},Z={__proto__:null,Nip47Error:M,Nip47NetworkError:W,Nip47WalletError:$,Nip47TimeoutError:F,Nip47PublishTimeoutError:L,Nip47ReplyTimeoutError:K,Nip47PublishError:j,Nip47ResponseDecodingError:J,Nip47ResponseValidationError:B,Nip47UnexpectedResponseError:H,Nip47UnsupportedEncryptionError:z,NWCClient:D,NWAClient:class{constructor(t){if(this.options=void 0,this.appSecretKey=void 0,this.relay=void 0,this.appSecretKey=t.appSecretKey||O(a()),this.options=h({},t,{appPubkey:n(C(this.appSecretKey))}),!this.options.relayUrl)throw new Error("Missing relay url");if(!this.options.requestMethods)throw new Error("Missing request methods");this.relay=new e(this.options.relayUrl),void 0===globalThis.WebSocket&&console.error("WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments")}get connectionUri(){return this.getConnectionUri()}getConnectionUri(e=""){const t=new URLSearchParams(h({relay:this.options.relayUrl,request_methods:this.options.requestMethods.join(" ")},this.options.name?{name:this.options.name}:{},this.options.icon?{icon:this.options.icon}:{},this.options.returnTo?{return_to:this.options.returnTo}:{},this.options.notificationTypes?{notification_types:this.options.notificationTypes.join(" ")}:{},this.options.maxAmount?{max_amount:this.options.maxAmount.toString()}:{},this.options.budgetRenewal?{budget_renewal:this.options.budgetRenewal}:{},this.options.expiresAt?{expires_at:this.options.expiresAt.toString()}:{},this.options.isolated?{isolated:this.options.isolated.toString()}:{},this.options.metadata?{metadata:JSON.stringify(this.options.metadata)}:{}));return`nostr+walletauth${e?`+${e}`:""}://${this.options.appPubkey}?${t.toString().replace(/\+/g,"%20")}`}static parseWalletAuthUrl(e){var t,n;if(!e.startsWith("nostr+walletauth"))throw new Error("Unexpected scheme. Should be nostr+walletauth:// or nostr+walletauth+specificapp://");const i=e.indexOf(":");(e=e.substring(i+1)).startsWith("//")&&(e=e.substring(2)),e="http://"+e;const s=new URL(e),o=s.host;if(64!==(null==o?void 0:o.length))throw new Error("Incorrect app pubkey found in auth string");const r=s.searchParams.get("relay");if(!r)throw new Error("No relay URL found in auth string");const a=null==(t=s.searchParams.get("request_methods"))?void 0:t.split(" ");if(null==a||!a.length)throw new Error("No request methods found in auth string");const c=null==(n=s.searchParams.get("notification_types"))?void 0:n.split(" "),l=s.searchParams.get("max_amount"),u=s.searchParams.get("expires_at"),h=s.searchParams.get("metadata");return{name:s.searchParams.get("name")||void 0,icon:s.searchParams.get("icon")||void 0,returnTo:s.searchParams.get("return_to")||void 0,relayUrl:r,appPubkey:o,requestMethods:a,notificationTypes:c,budgetRenewal:s.searchParams.get("budget_renewal"),expiresAt:u?parseInt(u):void 0,maxAmount:l?parseInt(l):void 0,isolated:"true"===s.searchParams.get("isolated"),metadata:h?JSON.parse(h):void 0}}async subscribe(e){var t=this;let n,i,s=!0;return async function(){for(;s;){try{await t._checkConnected();const s=t.relay.subscribe([{kinds:[13194],"#p":[t.options.appPubkey]}],{});console.info("subscribed to relay");const o=()=>{s.close(),t.relay.close()};s.onevent=async function(n){const i=new D({relayUrl:t.options.relayUrl,secret:t.appSecretKey,walletPubkey:n.pubkey});try{const e=await i.getInfo();i.options.lud16=e.lud16,i.lud16=e.lud16}catch(e){console.error("failed to fetch get_info",e)}e.onSuccess(i),o()},await new Promise(e=>{n=()=>{e()},i=()=>{console.info("relay disconnected"),null==n||n()},t.relay.onclose=i}),void 0!==i&&(t.relay.onclose=null)}catch(e){console.error("error subscribing to info event",e||"unknown relay error")}s&&await new Promise(e=>setTimeout(e,1e3))}}(),{unsub:()=>{s=!1,null==n||n()}}}async _checkConnected(){if(!this.appSecretKey)throw new Error("Missing secret key");if(!this.options.relayUrl)throw new Error("Missing relay url");try{this.relay.connected||await this.relay.connect()}catch(e){throw console.error("failed to connect to relay",this.options.relayUrl),new W("Failed to connect to "+this.options.relayUrl,"OTHER")}}},NWCWalletServiceKeyPair:class{constructor(e,t){if(this.walletSecret=void 0,this.walletPubkey=void 0,this.clientPubkey=void 0,this.walletSecret=e,this.clientPubkey=t,!this.walletSecret)throw new Error("Missing wallet secret key");if(!this.clientPubkey)throw new Error("Missing client pubkey");this.walletPubkey=n(C(this.walletSecret))}},NWCWalletService:class{constructor(t){this.relay=void 0,this.relayUrl=void 0,this.relayUrl=t.relayUrl,this.relay=new e(this.relayUrl),void 0===globalThis.WebSocket&&console.error("WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments")}async publishWalletServiceInfoEvent(e,t,n){try{await this._checkConnected();const i={kind:13194,created_at:Math.floor(Date.now()/1e3),tags:[["encryption","nip04 nip44_v2"],["notifications",n.join(" ")]],content:t.join(" ")},s=await this.signEvent(i,e);await this.relay.publish(s)}catch(e){throw console.error("failed to publish wallet service info event",e),e}}async subscribe(e,t){var n=this;let i,s,o,r=!0;return async function(){for(;r;){try{console.info("checking connection to relay"),await n._checkConnected(),console.info("subscribing to relay"),o=n.relay.subscribe([{kinds:[23194],authors:[e.clientPubkey],"#p":[e.walletPubkey]}],{}),console.info("subscribed to relay"),o.onevent=async function(i){try{var s;const o=(null==(s=i.tags.find(e=>"encryption"===e[0]))?void 0:s[1])||"nip04",r=await n.decrypt(e,i.content,o),a=JSON.parse(r);let c;switch(a.method){case"get_info":c=null==t.getInfo?void 0:t.getInfo();break;case"make_invoice":c=null==t.makeInvoice?void 0:t.makeInvoice(a.params);break;case"pay_invoice":c=null==t.payInvoice?void 0:t.payInvoice(a.params);break;case"pay_keysend":c=null==t.payKeysend?void 0:t.payKeysend(a.params);break;case"get_balance":c=null==t.getBalance?void 0:t.getBalance();break;case"lookup_invoice":c=null==t.lookupInvoice?void 0:t.lookupInvoice(a.params);break;case"list_transactions":c=null==t.listTransactions?void 0:t.listTransactions(a.params);break;case"sign_message":c=null==t.signMessage?void 0:t.signMessage(a.params)}let l=await c;l||(console.warn("received unsupported method",a.method),l={error:{code:"NOT_IMPLEMENTED",message:"This method is not supported by the wallet service"},result:void 0});const u={kind:23195,created_at:Math.floor(Date.now()/1e3),tags:[["e",i.id]],content:await n.encrypt(e,JSON.stringify(h({result_type:a.method},l)),o)},d=await n.signEvent(u,e.walletSecret);await n.relay.publish(d)}catch(e){return void console.error("Failed to parse decrypted event content",e)}},await new Promise(e=>{i=()=>{e()},s=()=>{console.error("relay disconnected"),null==i||i()},n.relay.onclose=s}),void 0!==s&&(n.relay.onclose=null)}catch(e){console.error("error subscribing to requests",e||"unknown relay error")}r&&await new Promise(e=>setTimeout(e,1e3))}}(),()=>{var e;r=!1,null==i||i(),null==(e=o)||e.close()}}get connected(){return this.relay.connected}signEvent(e,t){return Promise.resolve(i(e,C(t)))}close(){return this.relay.close()}async encrypt(e,t,n){let i;if("nip04"===n)i=await o.encrypt(e.walletSecret,e.clientPubkey,t);else{const n=r.getConversationKey(C(e.walletSecret),e.clientPubkey);i=r.encrypt(t,n)}return i}async decrypt(e,t,n){let i;if("nip04"===n)i=await o.decrypt(e.walletSecret,e.clientPubkey,t);else{const n=r.getConversationKey(C(e.walletSecret),e.clientPubkey);i=r.decrypt(t,n)}return i}async _checkConnected(){if(!this.relayUrl)throw new Error("Missing relay url");try{this.relay.connected||await this.relay.connect()}catch(e){throw console.error("failed to connect to relay",this.relayUrl),new W("Failed to connect to "+this.relayUrl,"OTHER")}}}};class ee{constructor(e,t){this.transaction=void 0,this.invoice=void 0,this._nwcClient=void 0,this._unsubscribeFunc=void 0,this._timeoutFunc=void 0,this._timeoutId=void 0,this.transaction=t,this.invoice=new c({pr:t.invoice}),this._nwcClient=e}onPaid(e){var t=this;return async function(){let n;try{var i;n=null==(i=(await t._nwcClient.getInfo()).notifications)?void 0:i.includes("payment_received")}catch(e){console.error("failed to fetch info, falling back to polling")}const s=n=>{null==t._unsubscribeFunc||t._unsubscribeFunc(),e(n)},o=e=>()=>{t._timeoutFunc=void 0,clearTimeout(t._timeoutId),e()};if(n){const e=e=>{e.notification.payment_hash===t.transaction.payment_hash&&s(e.notification)};t._unsubscribeFunc=o(await t._nwcClient.subscribeNotifications(e,["payment_received"]))}else console.warn("current connection does not support notifications, falling back to polling"),t._unsubscribeFunc=o(t._onPaidPollingFallback(s))}(),this}onTimeout(e,t){return this._timeoutFunc=()=>{var e;null==(e=this._unsubscribeFunc)||e.call(this),t()},this._timeoutId=setTimeout(()=>{var e;null==(e=this._timeoutFunc)||e.call(this)},1e3*e),this}unsubscribe(){var e;null==(e=this._unsubscribeFunc)||e.call(this)}_onPaidPollingFallback(e){var t=this;let n=!0;return async function(){for(;n;){const i=await t._nwcClient.lookupInvoice({payment_hash:t.transaction.payment_hash});if(i.settled_at&&i.preimage){e(i),n=!1;break}await new Promise(e=>setTimeout(e,3e3))}}(),()=>{n=!1}}}const te=e=>({satoshi:e});async function ne(e){if("number"==typeof e)return{satoshi:e,millisat:1e3*e};const t=await Promise.resolve(e.satoshi);return{satoshi:t,millisat:1e3*t}}class ie{constructor(e){this.nwcClient=void 0,this.nwcClient="string"==typeof e?new D({nostrWalletConnectUrl:e}):e instanceof D?e:new D(e)}async pay(e,t,n){let i=e;const s=t?await ne(t):void 0;if(i.indexOf("@")>-1){var o,r;if(!s)throw new Error("Amount must be provided when paying to a lightning address");const t=new l(e);await t.fetch(),i=(await t.requestInvoice({satoshi:s.satoshi,comment:null==n||null==(o=n.metadata)?void 0:o.comment,payerdata:null==n||null==(r=n.metadata)?void 0:r.payer_data})).paymentRequest}const a=await this.nwcClient.payInvoice(h({},n||{},{invoice:i,amount:null==s?void 0:s.millisat}));return h({},a,{invoice:new c({pr:i})})}async requestPayment(e,t){const n=await ne(e),i=await this.nwcClient.makeInvoice(h({},t||{},{amount:n.millisat}));return new ee(this.nwcClient,i)}close(){this.nwcClient.close()}}class se{constructor(e,t){this.satoshi=void 0,this.satoshi=u.getSatoshiValue({amount:e,currency:t})}}const oe=e=>new se(e,"USD"),re=e=>new se(e,"EUR"),ae=e=>new se(e,"JPY"),ce=e=>new se(e,"GBP"),le=e=>new se(e,"CHF");export{le as CHF,re as EUR,se as FiatAmount,ce as GBP,ae as JPY,ie as LN,ie as LNClient,ee as ReceiveInvoice,te as SATS,oe as USD,Z as nwc,A as oauth,ne as resolveAmount,Q as webln};
